<?php /** @noinspection DuplicatedCode */

namespace {{namespace}};

// Restful defaults
$staticNamespaces

// Custom User Imports
{{#CustomImports}}{{{CustomImports}}}{{/CustomImports}}

/**
 *
 * Class {{ucEachTableName}}
 * @package {{namespace}}
 * @note Note for convenience, a flag '-prefix' maybe passed to remove table prefixes.
 *  Use '-help' for a full list of options.
 * @link https://carbonphp.com/
 *
 * This class contains autogenerated code.
 * This class is a 1=1 relation named after a table in the database schema provided to the program `RestBuilder`.
 * Your edits are preserved during updates given they follow::
 *      METHODS SHOULD ONLY BE STATIC and may be reordered during generation.
 *      FUNCTIONS MUST NOT EXIST outside the class. (methods and functions are not the same.)
 *      IMPORTED CLASSED AND FUNCTIONS ARE ALLOWED though maybe reordered.
 *      ADDITIONAL CONSTANTS of any kind ARE NOT ALLOWED.
 *      ADDITIONAL CLASS MEMBER VARIABLES are NOT ALLOWED.
 *
 * When creating static member functions which require persistent variables, consider making them static members of that
 *  static method.
 */
class {{ucEachTableName}} extends Rest implements {{#primaryExists}}{{#multiplePrimary}}iRestMultiplePrimaryKeys{{/multiplePrimary}}{{^multiplePrimary}}iRestSinglePrimaryKey{{/multiplePrimary}}{{/primaryExists}}{{^primaryExists}}iRestNoPrimaryKey{{/primaryExists}}
{
    use RestfulValidations;

    public const CLASS_NAME = '{{ucEachTableName}}';
    public const CLASS_NAMESPACE = '{{namespace}}\\\\';
    public const TABLE_NAME = '{{TableName}}';
    public const TABLE_PREFIX = {{#prefixReplaced}}'{{prefix}}'{{/prefixReplaced}}{{^prefixReplaced}}''{{/prefixReplaced}};

    /**
     * COLUMNS
     * The columns below are a 1=1 mapping to the columns found in {{TableName}}.
     * Changes, shuch as adding or removing a column, SHOULD be made first in the database. The RestBuilder program will
     * capture any changes made in MySQL and update this file auto-magically.
    **/{{#explode}}
    public const {{caps}} = '{{TableName}}.{{name}}';
    {{/explode}}

    /**
     * PRIMARY
     * This could be null for tables without primary key(s), a string for tables with a single primary key, or an array
     * given composite primary keys. The existence and amount of primary keys of the will also determine the interface
     * aka method signatures used.
    **/
    public const PRIMARY = {{^primaryExists}}null{{/primaryExists}}{{#primaryExists}}{{#multiplePrimary}}[{{#primary}}{{#name}}'{{TableName}}.{{name}}',{{/name}}{{/primary}}
    ]{{/multiplePrimary}}{{^multiplePrimary}}{{#primary}}'{{TableName}}.{{name}}'{{/primary}}{{/multiplePrimary}}{{/primaryExists}};

    /**
     * COLUMNS
     * This is a convience constant for accessing your data after it has be returned from a rest operation. It is needed
     * as Mysql will strip away the tablename we have explicitly provided to each column (to help with join statments).
     * Thus, accessing your return values might look something like:
     *      \$return[self::COLUMNS[self::EXAMPLE_COLUMN_ONE]]
    **/
    public const COLUMNS = [
        {{#explode}}'{{TableName}}.{{name}}' => '{{name}}',{{/explode}}
];

public const PDO_VALIDATION = [
{{#explode}}'{{TableName}}.{{name}}' => ['{{mysql_type}}', '{{type}}', '{{length}}'],{{/explode}}
];

/**
* REFRESH_SCHEMA
* These directives should be designed to maintain and update your team's schema &| database &| table over time.
* It is RECOMMENDED that ALL changes you make in your local env be programmatically coded out in callables such as
* the 'tableExistsOrExecuteSQL' method call below. If a PDO exception is thrown with `\$e->getCode()` equal to 42S02
* or 1049 CarbonPHP will attempt to REFRESH the full database with with all directives in all tables. If possible
* keep table specific procedures in it's respective restful-class table file. Check out the 'tableExistsOrExecuteSQL'
* method in the parent class to see a more abstract procedure.
* Each directive MUST be designed to run multiple times without failure.
*/{{^REFRESH_SCHEMA}}
    public const REFRESH_SCHEMA = [
    [self::class => 'tableExistsOrExecuteSQL', self::TABLE_NAME, self::REMOVE_MYSQL_FOREIGN_KEY_CHECKS .
    PHP_EOL . self::CREATE_TABLE_SQL . PHP_EOL . self::REVERT_MYSQL_FOREIGN_KEY_CHECKS]
    ];{{/REFRESH_SCHEMA}}{{#REFRESH_SCHEMA}}
    {{{REFRESH_SCHEMA}}}
{{/REFRESH_SCHEMA}}

/**
* REGEX_VALIDATION
* Regular Expression validations will run before and recommended over PHP_VALIDATION.
* It is a 1 to 1 column regex relation with fully regex for preg_match_all(). This regex must satisfy the condition
*        1 > preg_match_all(self::\$compiled_regex_validations[\$column], \$value, ...
*
* Table generated column constants must be used.
*       self::EXAMPLE_COLUMN_NAME => '#^[A-F0-9]{20,35}$#i'
*
* @link https://regexr.com
* @link https://php.net/manual/en/function.preg-match-all.php
*/{{^regex_validation}}
    public const REGEX_VALIDATION = [];{{/regex_validation}}{{#regex_validation}}
    {{{regex_validation}}}
{{/regex_validation}}


/**
* PHP_VALIDATION
* PHP validations works as follows:
* @note regex validation is always step #1 and should be favored over php validations.
*  Syntax ::
*      [Example_Class::class => 'disallowPublicAccess', (optional) ...\$rest]
*      self::EXAMPLE_COLUMN => [Example_Class::class => 'exampleOtherMethod', (optional) ...\$rest]
*
*  Callables defined above MUST NOT RETURN FALSE. Moreover; return values are ignored so `): void {` may be used.
*  array_key_first() must return a fully qualified class namespace. In the example above Example_Class would be a
*  class defined in our system. PHP's `::class` appended to the end will return the fully qualified namespace. Note
*  this will require the custom import added to the top of the file. You can allow your editor to add these for you
*  as the RestBuilder program will capture, preserve, and possibly reorder the imports. The value of the first key
*  MUST BE the exact name of a member-method of that class. Typically validations are defined in the same class
*  they are used ('self::class') though it is useful to export more dynamic functions. The \$rest variable can be
*  used to add additional arguments to the request. RESTFUL INTERNAL ARGUMENTS will be passed before any use defined
*  variables after the first key value pair. Only array values will be passed to the method. Thus, additional keys
*  listed in the array will be ignored. Take for example::
*
*      [ self::class => 'validateUnique', self::class, self::EXAMPLE_COLUMN]
*  The above is defined in RestfulValidations::class.
*      RestfulValidations::validateUnique(string \$columnValue, string \$className, string \$columnName)
*  Its definition is with a trait this classes inherits using `use` just after the `class` keyword.
*
*   What is the RESTFUL lifecycle?
*      Regex validations are done first on any main query; sub-queries are treated like callbacks which get run
*      during the main queries invocation. The main query is 'paused' while the sub-query will compile and validate.
*      Validations across tables are concatenated on joins and sub-queries. All callbacks will be run across any
*       table joins.
*
*   What are the RESTFUL INTERNAL ARGUMENTS? (The single \$arg string or array passed before my own...)
*      REST_REQUEST_PREPROCESS_CALLBACKS ::
*           PREPROCESS::
*              Methods defined here will be called at the beginning of every request.
*              Each method will be passed ( & self::\$REST_REQUEST_PARAMETERS ) by reference so changes can be made pre-request.
*              Method validations under the main 'PREPROCESS' key will be run first, while validations specific to
*              ( GET | POST | PUT | DELETE )::PREPROCESS will be run directly after.
*
*           FINAL::
*              Each method will be passed the final ( & \$SQL ), which may be a sub-query, by reference.
*              Modifying the SQL string will effect the parent function. This can have disastrous effects.
*
*           COLUMN::
*              Preformed while a column is being parsed in a query. The first column validations to run.
*              Each column specific method under PREPROCESS will be passed nothing from rest.
*              Each method will ONLY be RUN ONCE regardless of how many times the column has been seen.
*
*      COLUMN::
*           Column validations are only run when they have been parsed in the query. Global column validations maybe
*            RUN MULTIPLE TIMES if the column is used multiple times in a single restful query.
*           If you have a column that is used multiple times the validations will run for each occurrence.
*           Column validation can mean many thing. There are three possible scenarios in which your method
*            signature would change. For this reason it is more common to use method ( GET | POST ... ) wise column validations.
*              *The signature required are as follows:
*                  Should the column be...
*                      SELECTED:
*                          In a select stmt no additional parameters will be passed.
*
*                      ORDERED BY: (self::ASC | self::DESC)
*                          The \$operator will be passed to the method.
*
*                      JOIN STMT:
*                          The \$operator followed by the \$value will be passed.
*                          The operator could be :: >,<,<=,<,=,<>,=,<=>
*
*      REST_REQUEST_FINNISH_CALLBACKS::
*          PREPROCESS::
*              These callbacks are called after a successful PDOStatement->execute() but before Database::commit().
*              Each method will be passed ( GET => &\$return, DELETE => &\$remove, PUT => &\$returnUpdated ) by reference.
*              POST will BE PASSED NULL.
*
*          FINAL::
*              Run directly after method specific [FINAL] callbacks.
*              The final, 'final' callback set. After these run rest will return.
*              Each method will be passed ( GET => &\$return, DELETE => &\$remove, PUT => &\$returnUpdated ) by reference.
*              POST will BE PASSED NULL.
*
*          COLUMN::
*              These callables will be run after the [( GET | POST | PUT | DELETE )][FINAL] methods.
*              Directly after, the [REST_REQUEST_FINNISH_CALLBACKS][FINAL] will run.
*
*
*      (POST|GET|PUT|DELETE)::
*          PREPROCESS::
*              Methods run after any root 'REST_REQUEST_PREPROCESS_CALLBACKS'
*              Each method will not be passed any argument from system. User arguments will be directly reflected.
*
*          COLUMN::
*              Methods run after any root column validations, the last of the PREPROCESS column validations to run.
*              Based on the existences and number of primary key(s), the signature will change.
*               See the notes on the base column validations as signature of parameters may change.
*              It is not possible to directly define a method->column specific post processes. This can be done by
*               dynamically pairing multiple method processes starting with one here which signals a code routine
*               in a `finial`-ly defined method. The FINAL block specific to the method would suffice.
*
*          FINAL::
*              Passed the ( & \$return )
*              Run before any other column validation
*
*  Be aware the const: self::DISALLOW_PUBLIC_ACCESS = [self::class => 'disallowPublicAccess'];
*  could be used to replace each occurrence of
*          [self::class => 'disallowPublicAccess', self::class]
*  though would loose information as self::class is a dynamic variable which must be used in this class given
*  static and constant context.
*  @version ^9
*/
{{^php_validation}}
    public const PHP_VALIDATION = [
    self::REST_REQUEST_PREPROCESS_CALLBACKS => [
    self::PREPROCESS => [
    [self::class => 'disallowPublicAccess', self::class],
    ]
    ],
    self::GET => [
    self::PREPROCESS => [
    [self::class => 'disallowPublicAccess', self::class],
    ]
    ],
    self::POST => [ self::PREPROCESS => [[ self::class => 'disallowPublicAccess', self::class ]]],
    self::PUT => [ self::PREPROCESS => [[ self::class => 'disallowPublicAccess', self::class ]]],
    self::DELETE => [ self::PREPROCESS => [[ self::class => 'disallowPublicAccess', self::class ]]],
    self::REST_REQUEST_FINNISH_CALLBACKS => [ self::PREPROCESS => [[ self::class => 'disallowPublicAccess', self::class ]]]
    ];{{/php_validation}}
{{#php_validation}}
    {{{php_validation}}}
{{/php_validation}}

/**
* CREATE_TABLE_SQL is autogenerated and should not be manually updated. Make changes in MySQL and regenerate using
* the RestBuilder program.
*/
public const CREATE_TABLE_SQL = /** @lang MySQL */ <<<MYSQL
    {{createTableSQL}}
        MYSQL;


{{{custom_methods}}}

/**
* @deprecated Use the class constant CREATE_TABLE_SQL directly
* @return string
*/
public static function createTableSQL() : string {
return self::CREATE_TABLE_SQL;
}

/**
* Currently nested aggregation is not supported. It is recommended to avoid using 'AS' where possible. Sub-selects are
* allowed and do support 'as' aggregation. Refer to the static subSelect method parameters in the parent `Rest` class.
* All supported aggregation is listed in the example below. Note while the WHERE and JOIN members are syntactically
* similar, and are moreover compiled through the same method, our aggregation is not. Please refer to this example
* when building your queries. By design, queries using subSelect are only allowed internally. Public Sub-Selects may
* be given an optional argument with future releases but will never default to on. Thus, you external API validation
* need only validate for possible table joins. In many cases sub-selects can be replaces using simple joins, this is
* highly recommended.
*
*   \$argv = [
*       Rest::SELECT => [
*              'table_name.column_name',                            // bad, dont pass strings manually. Use Table Constants instead.
*              self::EXAMPLE_COLUMN_ONE,                            // good,
*              [self::EXAMPLE_COLUMN_TWO, Rest::AS, 'customName'],
*              [Rest::COUNT, self::EXAMPLE_COLUMN_TWO, 'custom_return_name_using_as'],
*              [Rest::GROUP_CONCAT, self::EXAMPLE_COLUMN_THREE],
*              [Rest::MAX, self::EXAMPLE_COLUMN_FOUR],
*              [Rest::MIN, self::EXAMPLE_COLUMN_FIVE],
*              [Rest::SUM, self::EXAMPLE_COLUMN_SIX],
*              [Rest::DISTINCT, self::EXAMPLE_COLUMN_SEVEN],
*              ANOTHER_EXAMPLE_TABLE::subSelect(\$primary, \$argv, \$as, \$pdo, \$database)
*       ],
*       Rest::WHERE => [
*
*              self::EXAMPLE_COLUMN_NINE => 'Value To Constrain',                       // self::EXAMPLE_COLUMN_NINE AND
*              'Defaults to boolean AND grouping' => 'Nesting array switches to OR',    // ''='' AND
*              [
*                  'Column Name' => 'Value To Constrain',                                  // ''='' OR
*                  'This array is OR'ed together' => 'Another sud array would `AND`'       // ''=''
*                  [ etc... ]
*              ],
*              'last' => 'whereExample'                                                  // AND '' = ''
*        ],
*        Rest::JOIN => [
*            Rest::INNER => [
*                Carbon_Users::CLASS_NAME => [
*                    'Column Name' => 'Value To Constrain',
*                    'Defaults to AND' => 'Nesting array switches to OR',
*                    [
*                       'Column Name' => 'Value To Constrain',
*                       'This array is OR'ed together' => 'value'
*                       [ 'Another sud array would `AND`ed... ]
*                    ],
*                    [ 'Column Name', Rest::LESS_THAN, 'Another Column Name']           // NOTE the Rest::LESS_THAN
*                ]
*            ],
*            Rest::LEFT_OUTER => [
*                Example_Table::CLASS_NAME => [
*                    Location::USER_ID => Users::ID,
*                    Location_References::ENTITY_KEY => \$custom_var,
*
*                ],
*                Example_Table_Two::CLASS_NAME => [
*                    Example_Table_Two::ID => Example_Table_Two::subSelect(\$primary, \$argv, \$as, \$pdo, \$database)
*                    ect...
*                ]
*            ]
*        ],
*        Rest::PAGINATION => [
*              Rest::PAGE => (int) 0, // used for pagination which equates to
*                  // ... LIMIT ' . ((\$argv[self::PAGINATION][self::PAGE] - 1) * \$argv[self::PAGINATION][self::LIMIT])
*                  //       . ',' . \$argv[self::PAGINATION][self::LIMIT];
*
*              Rest::LIMIT => (int) 90, // The maximum number of rows to return,
*                       setting the limit explicitly to 1 will return a key pair array of only the
*                       singular result. SETTING THE LIMIT TO NULL WILL ALLOW INFINITE RESULTS (NO LIMIT).
*                       The limit defaults to 100 by design.
*
*               Rest::ORDER => [self::EXAMPLE_COLUMN_TEN => Rest::ASC ],  // i.e.  'username' => Rest::DESC
*         ],
*   ];
*
*
* @param array \$return{{#primaryExists}}
    * @param {{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}}|null \$primary{{/primaryExists}}
* @param array \$argv
* @noinspection DuplicatedCode - possible as this is generated
* @generated
* @throws PublicAlert|PDOException|JsonException
* @return bool
*/
public static function Get(array &\$return, {{#primaryExists}}{{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}} \$primary = null, {{/primaryExists}}array \$argv = []): bool
{
self::startRest(self::GET, \$return, \$argv {{#primaryExists}},\$primary{{/primaryExists}});

\$pdo = self::database();

\$sql = self::buildSelectQuery({{#primaryExists}}\$primary{{/primaryExists}}{{^primaryExists}}null{{/primaryExists}}, \$argv, {{^carbon_namespace}}{{#QueryWithDatabaseName}}'{{database}}'{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{^QueryWithDatabaseName}}''{{/QueryWithDatabaseName}}{{#carbon_namespace}}''{{/carbon_namespace}}, \$pdo);{{#json}}

    self::jsonSQLReporting(func_get_args(), \$sql);{{/json}}

self::postpreprocessRestRequest(\$sql);

\$stmt = \$pdo->prepare(\$sql);

self::bind(\$stmt);

if (!\$stmt->execute()) {
self::completeRest();
return self::signalError('The REST generated PDOStatement failed to execute with error :: ' . json_encode(\$stmt->errorInfo(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT));
}

\$return = \$stmt->fetchAll(PDO::FETCH_ASSOC);

/**
*   The next part is so every response from the rest api
*   formats to a set of rows. Even if only one row is returned.
*   You must set the third parameter to true, otherwise '0' is
*   apparently in the self::PDO_VALIDATION
*/

{{#primary}}{{#sql}}
    if (\$primary !== null || (isset(\$argv[self::PAGINATION][self::LIMIT]) && \$argv[self::PAGINATION][self::LIMIT] === 1 && count(\$return) === 1)) {
    \$return = isset(\$return[0]) && is_array(\$return[0]) ? \$return[0] : \$return;
    }
{{/sql}}{{/primary}}
{{^primary}}
    if (isset(\$argv[self::PAGINATION][self::LIMIT]) && \$argv[self::PAGINATION][self::LIMIT] === 1 && count(\$return) === 1) {
    \$return = isset(\$return[0]) && is_array(\$return[0]) ? \$return[0] : \$return;
    }
{{/primary}}
{{#explode}}{{#json}}
    if (array_key_exists('{{name}}', \$return)) {
    \$return['{{name}}'] = json_decode(\$return['{{name}}'], true);
    }
{{/json}}{{/explode}}

self::postprocessRestRequest(\$return);

self::completeRest();

return true;
}

/**
* @param array \$data
* @return bool|string{{#primaryExists}}|mixed{{/primaryExists}}
* @generated
* @throws PublicAlert|PDOException|JsonException
*/
public static function Post(array \$data){{^primaryExists}}: bool{{/primaryExists}}
{
self::startRest(self::POST, [], \$data);

foreach (\$data as \$columnName => \$postValue) {
if (!array_key_exists(\$columnName, self::PDO_VALIDATION)) {
return self::signalError("Restful table could not post column \$columnName, because it does not appear to exist.");
}
}

\$sql = 'INSERT INTO {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{TableName}} ({{listed}}) VALUES ({{{implode}}})';

{{^binary_primary}}
    \$pdo = self::database();

    if (!\$pdo->inTransaction()) {
    \$pdo->beginTransaction();
    }
{{/binary_primary}}

{{#json}}self::jsonSQLReporting(func_get_args(), \$sql);{{/json}}

self::postpreprocessRestRequest(\$sql);

\$stmt = self::database()->prepare(\$sql);{{#explode}}{{#primary_binary}}{{^carbon_table}}

    \${{name}} = \$id = \$data['{{TableName}}.{{name}}'] ?? false;
    if (\$id === false) {
    \${{name}} = \$id = self::fetchColumn('SELECT (REPLACE(UUID() COLLATE utf8_unicode_ci,"-",""))')[0];
    } else {
    \$ref='{{TableName}}.{{name}}';
    \$op = self::EQUAL;
    if (!self::validateInternalColumn(self::POST, \$ref, \$op, \${{name}})) {
    return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
    }
    }
    \$stmt->bindParam(':{{name}}',\${{name}}, {{type}}, {{length}});
{{/carbon_table}}{{#carbon_table}}
    \${{name}} = \$id = \$data['{{TableName}}.{{name}}'] ?? false;
    if (\$id === false) {
    \${{name}} = \$id = self::beginTransaction(self::class, \$data[self::DEPENDANT_ON_ENTITY] ?? null);
    } else {
    \$ref='{{TableName}}.{{name}}';
    \$op = self::EQUAL;
    if (!self::validateInternalColumn(self::POST, \$ref, \$op, \${{name}})) {
    return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
    }
    }
    \$stmt->bindParam(':{{name}}',\${{name}}, {{type}}, {{length}});
{{/carbon_table}}{{/primary_binary}}{{^primary_binary}}{{#skip}}{{#CURRENT_TIMESTAMP}}
    if (array_key_exists('{{TableName}}.{{name}}', \$data)) {
    return self::signalError('The column \'{{TableName}}.{{name}}\' is set to default to CURRENT_TIMESTAMP. The Rest API does not allow POST requests with columns explicitly set whose default is CURRENT_TIMESTAMP. You can remove to the default in MySQL or the column \'{{TableName}}.{{name}}\' from the request.');
    }
{{/CURRENT_TIMESTAMP}}{{/skip}}{{^skip}}{{^length}}{{#json}}
    if (!array_key_exists('{{TableName}}.{{name}}', \$data)) {
    return self::signalError('The column \'{{TableName}}.{{name}}\' is set to not null and has no default value. It must exist in the request and was not found in the one sent.');
    }
    \$ref = '{{TableName}}.{{name}}';
    \$op = self::EQUAL;
    if (!self::validateInternalColumn(self::POST, \$ref, \$op, \$data['{{name}}'])) {
    return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
    }
    if (!is_string(\${{name}} = \$data['{{TableName}}.{{name}}']) && false === \${{name}} = json_encode(\${{name}})) {
    return self::signalError('The column \'{{TableName}}.{{name}}\' failed to be json encoded.');
    }
    \$stmt->bindValue(':{{name}}', \${{name}}, {{type}});
{{/json}}{{^json}}{{^default}}
    if (!array_key_exists('{{TableName}}.{{name}}', \$data)) {
    return self::signalError('The column \'{{TableName}}.{{name}}\' is set to not null and has no default value. It must exist in the request and was not found in the one sent.');
    }
    \$ref='{{TableName}}.{{name}}';
    \$op = self::EQUAL;
    if (!self::validateInternalColumn(self::POST, \$ref, \$op, \$data['{{name}}'])) {
    return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
    }
    \$stmt->bindValue(':{{name}}', \$data['{{TableName}}.{{name}}'], {{type}});
{{/default}}{{#default}}
    \${{name}} = \$data['{{TableName}}.{{name}}'] ?? {{default}};
    \$ref='{{TableName}}.{{name}}';
    \$op = self::EQUAL;
    if (!self::validateInternalColumn(self::POST, \$ref, \$op, \${{name}}, \${{name}} === {{{default}}})) {
    return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
    }
    \$stmt->bindValue(':{{name}}', \${{name}}, {{type}});
{{/default}}{{/json}}{{/length}}{{#length}}{{^default}}
    if (!array_key_exists('{{TableName}}.{{name}}', \$data)) {
    return self::signalError('Required argument "{{TableName}}.{{name}}" is missing from the request.');
    }{{/default}}
\${{name}} = {{^default}}\$data['{{TableName}}.{{name}}'];{{/default}}{{#default}}\$data['{{TableName}}.{{name}}'] ?? {{{default}}};{{/default}}
\$ref='{{TableName}}.{{name}}';
\$op = self::EQUAL;
if (!self::validateInternalColumn(self::POST, \$ref, \$op, \${{name}}{{#default}}, \${{name}} === {{{default}}}{{/default}})) {
return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
}
\$stmt->bindParam(':{{name}}',\${{name}}, {{type}}, {{length}});
{{/length}}{{/skip}}{{/primary_binary}}{{/explode}}
if (!\$stmt->execute()) {
self::completeRest();
return self::signalError('The REST generated PDOStatement failed to execute with error :: ' . json_encode(\$stmt->errorInfo(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT));
}{{#binary_primary}}

    self::prepostprocessRestRequest(\$id);

    if (self::\$commit && !Database::commit()) {
    return self::signalError('Failed to store commit transaction on table {{TableName}}');
    }

    self::postprocessRestRequest(\$id);

    self::completeRest();

    return \$id;
{{/binary_primary}}{{^binary_primary}}{{#auto_increment_return_key}}

    \$id = \$pdo->lastInsertId();{{/auto_increment_return_key}}

self::prepostprocessRestRequest({{#auto_increment_return_key}}\$id{{/auto_increment_return_key}});

if (self::\$commit && !Database::commit()) {
return self::signalError('Failed to store commit transaction on table {{TableName}}');
}

self::postprocessRestRequest({{#auto_increment_return_key}}\$id{{/auto_increment_return_key}});

self::completeRest();

return {{^auto_increment_return_key}}true{{/auto_increment_return_key}}{{#auto_increment_return_key}}\$id{{/auto_increment_return_key}};  {{/binary_primary}}
}

/**
*
* {{^primaryExists}}
    *  Syntax should be as follows.
    *  \$argv = [
    *       Rest::UPDATE => [
    *              ...
    *       ],
    *       Rest::WHERE => [
    *              ...
    *       ]
    * {{/primaryExists}}{{#primaryExists}}
    * Tables where primary keys exist must be updated by its primary key.
    * Column should be in a key value pair passed to \$argv or optionally using syntax:
    * \$argv => [
    *       Rest::UPDATE => [
    *              ...
    *       ]
    * ]
    * {{/primaryExists}}
* @param array \$returnUpdated - will be merged with with array_merge, with a successful update.
{{#primaryExists}}* @param string \$primary{{/primaryExists}}
* @param array \$argv
* @generated
* @throws PublicAlert|PDOException|JsonException
* @return bool - if execute fails, false will be returned and \$returnUpdated = \$stmt->errorInfo();
*/
public static function Put(array &\$returnUpdated, {{#primaryExists}}{{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}} \$primary = null,{{/primaryExists}} array \$argv) : bool
{
self::startRest(self::PUT, \$returnUpdated, \$argv{{#primaryExists}}, \$primary{{/primaryExists}});

{{#primaryExists}}
    if (false === self::\$allowFullTableUpdates && ({{^multiplePrimary}}''{{/multiplePrimary}}{{#multiplePrimary}}[]{{/multiplePrimary}} === \$primary || null === \$primary)) {
    return self::signalError('Restful tables which have a primary key must be updated by its primary key. To bypass this set you may set `self::\$allowFullTableUpdates = true;` during the PREPROCESS events.');
    }

    \$where = [];

    if (array_key_exists(self::WHERE, \$argv)) {
    \$where = \$argv[self::WHERE];
    unset(\$argv[self::WHERE]);
    }

    if (array_key_exists(self::UPDATE, \$argv)) {
    \$argv = \$argv[self::UPDATE];
    }
    {{#multiplePrimary}}
        if (count(array_intersect_key(\$primary, self::PRIMARY)) !== count(self::PRIMARY)) {
        return self::signalError('You must provide all primary keys (' . implode(', ', self::PRIMARY) . ').');
        }

        \$where = array_merge(\$argv, \$primary);
    {{/multiplePrimary}}{{^multiplePrimary}}
        \$where[self::PRIMARY] = \$primary;
    {{/multiplePrimary}}{{/primaryExists}}{{^primaryExists}}
    \$where = \$argv[self::WHERE] ?? [];

    if (false === self::\$allowFullTableUpdates && empty(\$where)) {
    return self::signalError('Restful tables which have no primary key must be updated using conditions given to \$argv[self::WHERE] and values to be updated given to \$argv[self::UPDATE]. No WHERE attribute given. To bypass this set `self::\$allowFullTableUpdates = true;` during the PREPROCESS events, or just directly before this request.');
    }

    \$argv = \$argv[self::UPDATE] ?? [];

    if (empty(\$argv)) {
    return self::signalError('Restful tables which have no primary key must be updated using conditions given to \$argv[self::WHERE] and values to be updated given to \$argv[self::UPDATE]. No UPDATE attribute given.');
    }{{/primaryExists}}

foreach (\$argv as \$key => &\$value) {
if (!array_key_exists(\$key, self::PDO_VALIDATION)){
return self::signalError('Restful table could not update column \$key, because it does not appear to exist. Please re-run RestBuilder if you beleive this is incorrect.');
}
\$op = self::EQUAL;
if (!self::validateInternalColumn(self::PUT, \$key, \$op, \$value)) {
return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
}
}
unset(\$value);

\$sql = /** @lang MySQLFragment */ 'UPDATE {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{TableName}} SET '; // intellij cant handle this otherwise

\$set = '';

{{#explode}}
    if (array_key_exists('{{TableName}}.{{name}}', \$argv)) {
    \$set .= '{{name}}={{#binary}}UNHEX(:{{name}}){{/binary}}{{^binary}}:{{name}}{{/binary}},';
    }
{{/explode}}

\$sql .= substr(\$set, 0, -1);

\$pdo = self::database();

if (!\$pdo->inTransaction()) {
\$pdo->beginTransaction();
}

if (false === self::\$allowFullTableUpdates || !empty(\$where)) {
\$sql .= ' WHERE ' . self::buildBooleanJoinConditions(self::PUT, \$where, \$pdo);
}

{{#json}}self::jsonSQLReporting(func_get_args(), \$sql);{{/json}}

self::postpreprocessRestRequest(\$sql);

\$stmt = \$pdo->prepare(\$sql);

{{#explode}}
    if (array_key_exists('{{TableName}}.{{name}}', \$argv)) { {{^length}}
        \$stmt->bindValue(':{{name}}',{{#json}}json_encode(\$argv['{{TableName}}.{{name}}']){{/json}}{{^json}}\$argv['{{TableName}}.{{name}}']{{/json}}, {{type}});{{/length}}{{#length}}
        \${{name}} = \$argv['{{TableName}}.{{name}}'];
        \$ref = '{{TableName}}.{{name}}';
        \$op = self::EQUAL;
        if (!self::validateInternalColumn(self::PUT, \$ref, \$op, \${{name}})) {
        return self::signalError('Your custom restful api validations caused the request to fail on column \'{{name}}\'.');
        }
        \$stmt->bindParam(':{{name}}',\${{name}}, {{type}}, {{length}});{{/length}}
    }
{{/explode}}
self::bind(\$stmt);

if (!\$stmt->execute()) {
self::completeRest();
return self::signalError('The REST generated PDOStatement failed to execute with error :: ' . json_encode(\$stmt->errorInfo(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT));
}

if (!\$stmt->rowCount()) {
return self::signalError('Failed to find the target row.');
}

\$argv = array_combine(
array_map(
static function(\$k) { return str_replace('{{TableName}}.', '', \$k); },
array_keys(\$argv)
),
array_values(\$argv)
);

\$returnUpdated = array_merge(\$returnUpdated, \$argv);

self::prepostprocessRestRequest(\$returnUpdated);

if (self::\$commit && !Database::commit()) {
return self::signalError('Failed to store commit transaction on table {{TableName}}');
}

self::postprocessRestRequest(\$returnUpdated);

self::completeRest();

return true;
}

/**
* @param array \$remove{{#primaryExists}}
    * @param string|null \$primary{{/primaryExists}}
* @param array \$argv
* @generated
* @noinspection DuplicatedCode
* @throws PublicAlert|PDOException|JsonException
* @return bool
*/
public static function Delete(array &\$remove, {{#primaryExists}}{{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}} \$primary = null, {{/primaryExists}}array \$argv = []) : bool
{
self::startRest(self::DELETE, \$remove, \$argv{{#primaryExists}}, \$primary{{/primaryExists}});

{{#carbon_table}}
    if (null !== \$primary) {
    return Carbons::Delete(\$remove, \$primary, \$argv);
    }

    if (false === self::\$allowFullTableDeletes && empty(\$argv)) {
    return self::signalError('When deleting from restful tables a primary key or where query must be provided.');
    }

    \$sql = 'DELETE c FROM {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}carbons c
    JOIN {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{TableName}} on c.entity_pk = {{#primary}}{{#name}}{{TableName}}.{{name}}{{/name}}{{/primary}}';


    if (false === self::\$allowFullTableDeletes || !empty(\$argv)) {
    \$sql .= ' WHERE ' . self::buildBooleanJoinConditions(self::DELETE, \$argv, \$pdo);
    }
{{/carbon_table}}
{{^carbon_table}}
    \$sql =  /** @lang MySQLFragment */ 'DELETE FROM {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{TableName}} ';

    {{#primary}}
        if (false === self::\$allowFullTableDeletes && (null === \$primary || {{^multiplePrimary}}''{{/multiplePrimary}}{{#multiplePrimary}}[]{{/multiplePrimary}} === \$primary) && empty(\$argv)) {
        return self::signalError('When deleting from restful tables a primary key or where query must be provided. This can be disabled by setting `self::\$allowFullTableUpdates = true;` during the PREPROCESS events, or just directly before this request.');
        }{{#multiplePrimary}}

            \$primaryIntersect = count(array_intersect_key(\$primary, self::PRIMARY));

            \$primaryCount = count(\$primary);

            if (\$primaryCount !== \$primaryIntersect) {
            return self::signalError('The keys provided to table {{TableName}} was not a subset of (' . implode(', ', self::PRIMARY) . '). Only primary keys associated with the root table requested, thus not joined tables, are allowed.');
            }

            if (false === self::\$allowFullTableDeletes && \$primaryIntersect !== count(self::PRIMARY)) {
            return self::signalError('You must provide all primary keys (' . implode(', ', self::PRIMARY) . '). This can be disabled by setting `self::\$allowFullTableUpdates = true;` during the PREPROCESS events, or just directly before this request.');
            }

            \$argv = array_merge(\$argv, \$primary);
        {{/multiplePrimary}}{{^multiplePrimary}}

            if ('' !== \$primary) {
            \$argv[self::PRIMARY] = \$primary;
            }
        {{/multiplePrimary}}

        \$where = self::buildBooleanJoinConditions(self::DELETE, \$argv, \$pdo);

        if (false === self::\$allowFullTableDeletes && empty(\$where)) {
        return self::signalError('The where condition provided appears invalid.');
        }

        \$sql .= ' WHERE ' . \$where;

    {{/primary}}

{{^primary}}
        if (empty(\$argv)) {
        return self::signalError('When deleting from tables with out a primary key additional arguments must be provided.');
        }

        \$sql .= ' WHERE ' . self::buildBooleanJoinConditions(self::DELETE, \$argv, \$pdo);{{/primary}}

{{/carbon_table}}

\$pdo = self::database();

if (!\$pdo->inTransaction()) {
\$pdo->beginTransaction();
}

{{#json}}self::jsonSQLReporting(func_get_args(), \$sql);{{/json}}

self::postpreprocessRestRequest(\$sql);

\$stmt = \$pdo->prepare(\$sql);

self::bind(\$stmt);

if (!\$stmt->execute()) {
self::completeRest();
return self::signalError('The REST generated PDOStatement failed to execute with error :: ' . json_encode(\$stmt->errorInfo(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT));
}

\$remove = [];

self::prepostprocessRestRequest(\$remove);

if (self::\$commit && !Database::commit()) {
return self::signalError('Failed to store commit transaction on table {{TableName}}');
}

self::postprocessRestRequest(\$remove);

self::completeRest();

return true;

}

}

