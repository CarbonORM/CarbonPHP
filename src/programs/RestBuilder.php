<?php /** @noinspection ForgottenDebugOutputInspection */

namespace CarbonPHP\Programs;


use CarbonPHP\CarbonPHP;
use CarbonPHP\Interfaces\iColorCode;
use CarbonPHP\Interfaces\iCommand;
use CarbonPHP\Interfaces\iRest;
use CarbonPHP\Interfaces\iRestfulReferences;
use CarbonPHP\Interfaces\iRestMultiplePrimaryKeys;
use CarbonPHP\Interfaces\iRestNoPrimaryKey;
use CarbonPHP\Interfaces\iRestSinglePrimaryKey;
use CarbonPHP\Rest;
use CarbonPHP\Tables\Carbons;
use DirectoryIterator;
use ReflectionException;
use ReflectionMethod;
use function count;
use function in_array;
use function random_int;


class RestBuilder implements iCommand
{
    use ColorCode, Composer, Background, MySQL {
        cleanUp as removeFiles;
    }

    private string $schema;
    private string $user;
    private string $password;
    private bool $cleanUp = false;

    public function cleanUp(): void
    {
        $this->cleanUp and $this->removeFiles();
    }

    public function usage(): void
    {
        print <<<END
\n
\t           Question Marks Denote Optional Parameters
\t           Order does not matter.
\t           Flags do not stack ie. not -edf, this -e -f -d
\t Usage::
\t  php index.php rest  

\t       -help                        - this dialogue 

\t       -h [HOST]                    - IP address

\t       -s [SCHEMA]                  - Its that tables schema!!!!
\t                                              Defaults to DB_NAME in config file passed to CarbonPHP
\t                                              Currently: "$this->schema"

\t       -u [USER]                    - mysql username
\t                                              Defaults to DB_USER in config file passed to CarbonPHP
\t                                              Currently: "$this->user"

\t       -p [PASSWORD]                - if ya got one
\t                                              Defaults to DB_PASS in config file passed to CarbonPHP
\t                                              Currently: "$this->password"

\t       -autoTarget                   - Use composer.json's ['autoload']['psr-4']['Tables\\'] value under CarbonPHP::\$app_root

\t       -target [rest_dir_path]       - the dir to store the rest generated api
\t                                              Defaults to CarbonPHP::\$app_root . 'tables/'

\t       -namespace [full_namespace]   - the namespace to assign each table to. 
\t                                              Defaults to 'Tables\\'

\t       -prefix                       - prefix to remove from class names. Defaults to none ''.

\t       -excludeTablesRegex           - pass a valid php regex with delimiters. If a table name matches the regular expression     
                                                the table will be skipped and thus not generated. 
                                                ex.   
                                                 -excludeTablesRegex '#_migration_.*#i'   

\t       -dontQueryWithDatabaseName    - This will remove the explicit resolution of the database name in queries. This 
                                                if useful when your environments use different database names with the same structure. 
                                                Avoid using this option if possible. 

\t       -json                         - enable global json reporting (recommended)

\t       -r                            - specify that a primary key is required for generation

\t       -l [tableName(s),[...?,[]]]  - comma separated list of specific tables to capture

\t       -v [?debug]                   - Verbose output, if === debug follows this tag even more output is given

\t       -f [file_of_Tables]           - file of tables names separated by eol

\t       -x                            - Stops the file clean up files created for build

\t       -mysqldump [executable]       - path to mysqldump command

\t       -mysql  [executable]          - path to mysql command

\t       -dump [dump]                  - path to a mysqldump sql export

\t       -cnf [cnf_path]               - path to a mysql cnf file

\t       -trigger                      - build triggers and history tables for binary primary keys

\t       -react [Dir_Path]             - creates a smart reference for you rest tsx generated template output             
\n
\t       -dumpData                     - will create mysqldump_data.sql to project root, 
\t                                              everything except table definitions which are generated by default and 
\t                                              stored in the /mysqldump.sql file.
\n
END;
        exit(1);
    }

    /**
     * Rest constructor.
     * @param $CONFIG
     */
    public function __construct($CONFIG)
    {
        ini_set('memory_limit', '2048M');  // TODO - make this a config variable
        [$CONFIG] = $CONFIG;
        $this->schema = $CONFIG['DATABASE']['DB_NAME'] ?? '';
        $this->user = $CONFIG['DATABASE']['DB_USER'] ?? '';
        $this->password = $CONFIG['DATABASE']['DB_PASS'] ?? '';
    }

    public function run(array $argv): void
    {
        // Check command line args, password is optional
        self::colorCode("\tBuilding Rest Api!\n", 'blue');

        // C syntax
        $argc = count($argv);

        // set default values
        $rest = [];
        $QueryWithDatabaseName = $clean = true;
        $json = $carbon_namespace = CarbonPHP::$app_root . 'src' . DS === CarbonPHP::CARBON_ROOT;
        $targetDir = CarbonPHP::$app_root . ($carbon_namespace ? 'src/tables/' : 'tables/');
        $only_these_tables = $history_table_query = $mysql = null;
        $verbose = $debug = $primary_required = $delete_dump = $skipTable = $logClasses =
        $javascriptBindings = $dumpData = false;
        $target_namespace = 'Tables\\';
        $prefix = '';
        $exclude_these_tables = [];
        $excludeTablesRegex = null;

        $react = $carbon_namespace ? CarbonPHP::$app_root . 'view/assets/react/src/variables/' : false;

        // TODO - we shouldn't open ourselfs for sql injection, was this a bandage
        try {
            $subQuery = 'C6SUB' . random_int(0, 1000);
        } catch (\Exception $e) {
            $subQuery = 'C6SUBTX2';
        }

        /** @noinspection ForeachInvariantsInspection - as we need $i++ */
        for ($i = 0; $i < $argc; $i++) {
            switch ($argv[$i]) {
                case '-dumpData':
                    $dumpData = true;
                    break;
                case '-javascript':
                    $javascriptBindings = $argv[++$i];
                    if ($react === false) {
                        $react = $javascriptBindings;
                    }
                    break;
                case '-excludeTablesRegex':
                    $excludeTablesRegex = $argv[++$i];
                    break;
                case '-dontQueryWithDatabaseName':
                    $QueryWithDatabaseName = false;
                    break;
                case '-react':
                    if ($carbon_namespace) {
                        self::colorCode("\tReact directory hardcoded for C6, unnecessary flag.\n", 'blue');
                        break;
                    }
                    $react = $argv[++$i];
                    break;

                case '-prefix':
                    $prefix = $argv[++$i];
                    break;
                case '-namespace':
                    $target_namespace = $argv[++$i];

                    $target_namespace_array = explode('\\', $target_namespace);

                    $target_namespace_array = array_filter($target_namespace_array);

                    $target_namespace = implode('\\', $target_namespace_array);

                    if (count($target_namespace_array) === 1) {
                        switch (strtolower(readline("Does the namespace ($target_namespace) look correct? [Y,n]"))) {
                            default:
                                break;
                            case 'no':
                            case 'n':
                                /** @noinspection PhpUnhandledExceptionInspection */
                                self::colorCode('You may need to add more escaping "\\" depending on how may contexts the string goes through. We will try to fix over escaped namespaces.', 'red', true);
                        }
                    }

                    break;
                case '-json':
                    $json = true;
                    break;
                case '-autoTarget':
                    if ($carbon_namespace) {
                        break;
                    }
                    $composer = self::getComposerConfig();
                    $composer = $composer['autoload']['psr-4']["Tables\\"] ?? false;
                    if (!$composer) {
                        print "\n\nFailed to find an entry for ['autoload']['psr-4']['Tables\\'] in your composer.json\n" .
                            "\tThe -autoTarget flag failed the build.";
                        exit(1);
                    }
                    $targetDir = CarbonPHP::$app_root . $composer;
                    unset($composer);
                    break;
                case '-target':
                    $targetDir = $argv[++$i];
                    break;
                case '-subPrefix':
                    $subQuery = $argv[++$i];
                    break;
                case '-x':
                    $this->cleanUp = true;
                    break;
                case '-v':
                    if (isset($argv[++$i]) && strtolower($argv[$i]) === 'debug') {
                        print "\tDebug mode is best when paired with the optional (-l or -f) flags. Use -help for more information.\n";
                        $debug = true;
                    } else {
                        --$i;
                    }
                    $verbose = true;
                    break;
                case '-carbon':
                    $carbon_namespace = true;
                    break;
                case '-trigger':
                    $history_table_query = true;
                    $query = <<<QUERY
CREATE TABLE IF NOT EXISTS carbon_history_logs
(
  uuid BINARY(16) NULL,
  resource_type VARCHAR(10) NULL,
  resource_uuid BINARY(16) NULL,
  operation_type VARCHAR(16) NULL COMMENT 'POST|PUT|DELETE',
  data BLOB NULL,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP NOT NULL,
  modified_by INT(16) NULL
);
QUERY;
                    file_put_contents('triggers.sql', $query);
                    break;
                case '-help':
                    $this->usage();
                    break;          // unneeded but my editor complains
                case '-h':
                    $this->CONFIG['DATABASE']['DB_HOST'] = $argv[++$i];
                    break;
                case '-s':
                    $this->schema = $argv[++$i];
                    break;
                case '-r':
                    $primary_required = true;
                    break;
                case '-u':
                    $this->CONFIG['DATABASE']['DB_USER'] = $argv[++$i];
                    break;
                case '-p':
                    $this->CONFIG['DATABASE']['DB_PASS'] = $argv[++$i];
                    break;
                case '-l':
                    // This argument is for specifying the
                    $only_these_tables = explode(',', $argv[++$i]);
                    break;
                case '-f':
                    if (empty($file = file_get_contents((string)$argv[++$i]))) {
                        print 'Could not open file [ ' . $argv[$i] . " ] for input\n\n";
                        exit(1);
                    }
                    $only_these_tables = explode(PHP_EOL, $file);
                    unset($file);
                    break;
                case '-excludeFile':
                    if (empty($file = file_get_contents((string)$argv[++$i]))) {
                        print 'Could not open file [ ' . $argv[$i] . " ] for input\n\n";
                        exit(1);
                    }
                    $exclude_these_tables = explode(PHP_EOL, $file);
                    unset($file);
                    break;
                case '-mysqldump':
                    // the path to the mysqldump executable
                    $mysqldump = $argv[++$i];
                    break;
                case '-mysql':
                    // the path to the mysql executable
                    $mysql = $argv[++$i];
                    break;
                case '-dump':
                    // path to an sql dump file
                    $dump = $argv[++$i];
                    break;
                case '-cnf':
                    // path to an sql cnf pass file
                    $this->buildCNF($argv[++$i]);
                    break;
                case '-logClasses':
                    $logClasses = true;
                    break;
                default:
                    print "\tInvalid flag " . $argv[$i] . PHP_EOL;
                    print <<<END
\n\n\t
\t      "You are young
\t      and life is long
\t      and there is time
\t      to kill today.
\t      And then one day you find
\t      ten years have got behind you.
\t      No one told you when to run,
\t      you missed the starting gun!"
\t
\t      - 'Time' Pink Floyd
\n\n
END;
                    exit(1);
            }
        }


        $determineIfTableShouldBeSkipped = static function ($tableName) use ($exclude_these_tables, $only_these_tables, $history_table_query, $excludeTablesRegex, $verbose): ?bool {
            // 'only these tables' is specified in the command line arguments (via file or comma list)
            if ((!empty($exclude_these_tables) && in_array($tableName, $exclude_these_tables, true))
                || (!empty($only_these_tables) && !in_array($tableName, $only_these_tables, true))
                || ($excludeTablesRegex !== null && preg_match($excludeTablesRegex, $tableName))) {
                // Break from this loop (every line in the create) and the parent loop (the tables)
                if ($verbose) {
                    ColorCode::colorCode('Skipping ' . $tableName . PHP_EOL);
                }
                // this is our condition to check right after this tables is executed
                $skipTable = true;
                // We may need to analyse for foreign keys, we will still break after this foreach loop
                if (!$history_table_query) {
                    return true;
                }
                return null;            // the table will be skipped, but parsed to generate the necessary relational mappings
            }
            return false;
        };

        if (empty($targetDir)) {
            print 'You must provide a target directory.' . PHP_EOL;
            $this->usage();
        } else if (!is_dir($targetDir)) {
            print 'Directory does not exist, attempting to create it.' . PHP_EOL;
            if (!mkdir($targetDir, 0755, true) && !is_dir($targetDir)) {
                print 'The target directory appears invalid "' . $targetDir . '"' . PHP_EOL;
                exit(1);
            }
        }

        if ('/' !== substr($targetDir, -1)) {
            $targetDir .= DS;
        }

        if (empty($this->schema) || $this->schema === '') {
            print 'You must specify the table schema!' . PHP_EOL;
            exit(1);
        }

        self::$mysqldump = $dumpFilePath = $dump ?? self::mysqldump($mysqldump ?? null, $dumpData);

        if (!file_exists(self::$mysqldump)) {
            print 'Could not load mysql dump file!' . PHP_EOL;
            exit(1);
        }

        if (empty(self::$mysqldump = file_get_contents(self::$mysqldump))) {
            print 'Contents of the mysql dump file appears empty. Build Failed!';
            exit(1);
        }

        // This is our mustache template engine implemented in php, used for rendering user content
        $mustache = new \Mustache_Engine();

        $verbose and var_dump(self::$mysqldump);

        // match all tables from a mysql dump
        preg_match_all('#CREATE\s+TABLE(.|\s)+?(?=ENGINE=)ENGINE=.+;#', self::$mysqldump, $matches);


        // from version ^9.1 to ^9.2 a deprecation/update was made in an interface...
        $dir = new DirectoryIterator($targetDir);
        foreach ($dir as $fileinfo) {
            if (!$fileinfo->isDot()) {
                $filename = $fileinfo->getFilename();

                $verbose and ColorCode::colorCode('Checking version information of ' . $targetDir . $filename, iColorCode::MAGENTA);

                $text = file_get_contents($targetDir.$filename);

                if (
                    strpos($text, 'iRestMultiplePrimaryKeys') === false &&
                    strpos($text, 'iRestNoPrimaryKey') === false &&
                    strpos($text, 'iRestSinglePrimaryKey') === false
                ) {
                    continue;
                }

                $count = $count2 = $count3 = 0;

                $text = preg_replace('#public static function Post\(array \$data\)#', 'public static function Post(array $data = [])', $text, 1, $count);
                $text = preg_replace('#public static function Put\(array &\$returnUpdated, string \$primary, array \$argv\)#', 'public static function Put(array &$returnUpdated, string $primary = null, array $argv = [])', $text, 1, $count2);
                $text = preg_replace('#public static function Put\(array &\$returnUpdated, array \$primary, array \$argv\)#', 'public static function Put(array &$returnUpdated, array $primary = null, array $argv = [])', $text, 1, $count2);
                $text = preg_replace('#public static function Put\(array &\$returnUpdated, array \$argv\)#', 'public static function Put(array &$returnUpdated, array $argv = [])', $text, 1, $count3);
                $count += $count2 + $count3;

                if ($count === 0) {
                    $verbose and ColorCode::colorCode('No breaking changes detected in ' . $targetDir . $filename, iColorCode::GREEN);
                    continue;
                }

                ColorCode::colorCode('The file (' . $targetDir . $filename . ') was updated to handle the 9.1 - 9.2 interface deprecation.', iColorCode::CYAN);

                if (false === file_put_contents($targetDir.$filename, $text)) { // if you run into this; I'm sorry, but I didn't have issues with it
                    ColorCode::colorCode('A fatal error has occurred. Manually updating php code via text for interface changes failed. Refer to the code to fix this...', iColorCode::RED);
                    die;
                }
            }
        }
        unset($text);


        // I just want the list of matches, nothing more.
        $matches = $matches[0];

        // Every CREATE TABLE as tables
        foreach ($matches as $table) {
            if (isset($foreign_key)) {
                unset($foreign_key);
            }

            $createTableSQL = $table;
            // Separate each insert line by new line feed \n
            $table = explode(PHP_EOL, $table);
            $binary = $skipping_col = $primary = [];
            $tableName = '';
            $column = 0;

            // Every line in tables insert
            foreach ($table as $words_in_insert_stmt) {

                // binary column default values are handled by mysql.
                $cast_binary_default = false;

                // Separate each line in the tables creation by spaces
                $words_in_insert_stmt = explode(' ', trim($words_in_insert_stmt));

                // We can assume that this is the first line of the tables insert

                switch ($words_in_insert_stmt[0]) {
                    case 'CREATE':
                        $tableName = trim($words_in_insert_stmt[2], '`');               // Table Name

                        // TRY to load previous validation functions

                        $rest[$tableName] = [
                            'prefix' => $prefix,
                            'createTableSQL' => Rest::parseSchemaSQL($createTableSQL) . ';',
                            'subQuery' => $subQuery,
                            'subQueryLength' => strlen($subQuery),
                            'QueryWithDatabaseName' => $QueryWithDatabaseName,
                            'json' => $json,
                            'binary_primary' => false,
                            'carbon_namespace' => $carbon_namespace,
                            'namespace' => $carbon_namespace ? 'CarbonPHP\Tables' : $target_namespace,
                            'carbon_table' => false,
                            'database' => $this->schema,
                            // We need to catch circular dependencies
                            'dependencies' => $rest[$tableName]['dependencies'] ?? [],
                            'TableName' => $tableName,
                            'prefixReplaced' => $noPrefix = preg_replace("/^$prefix/", '', $tableName),
                            'ucEachTableName' => $etn = implode('_', array_map('ucfirst', explode('_', $noPrefix))),
                            'strtolowerNoPrefixTableName' => strtolower($etn),  // its best to leave this like this as opposed to = $noPrefix
                            'primarySort' => '',
                            'custom_methods' => '',
                            'primary' => [],
                        ];

                        // 'only these tables' is specified in the command line arguments (via file or comma list)
                        if ($determineIfTableShouldBeSkipped($tableName) === true) {
                            $skipTable = true;
                            continue 2;
                        }

                        if (file_exists($validation = $targetDir . $etn . '.php')) {
                            $validation = file_get_contents($validation);

                            preg_match_all('#public const REGEX_VALIDATION\s?=\s? \[(.|\n)*?];(?=(\s|\n)+(public|protected|private|/\*))#', $validation, $matches);

                            if (isset($matches[0][0])) {
                                $rest[$tableName]['regex_validation'] = $matches[0][0];
                            }

                            preg_match_all('#public const PHP_VALIDATION\s?=\s? \[(.|\n)*?];(?=(\s|\n)+(public|protected|private|/\*))#', $validation, $matches);

                            if (isset($matches[0][0])) {
                                $rest[$tableName]['php_validation'] = $matches[0][0];
                            }

                            preg_match_all('#public const REFRESH_SCHEMA\s?=\s? \[(.|\n)*?];(?=(\s|\n)+(public|protected|private|/\*))#', $validation, $matches);

                            if (isset($matches[0][0])) {
                                $rest[$tableName]['REFRESH_SCHEMA'] = $matches[0][0];
                            }

                            $restStaticNameSpaces = $this->restTemplateStaticNameSpace();

                            array_splice($restStaticNameSpaces, 2, 0, [
                                'use CarbonPHP\Interfaces\iRest;',
                                'use CarbonPHP\Interfaces\iRestfulReferences;',
                                'use CarbonPHP\Interfaces\iRestMultiplePrimaryKeys;',
                                'use CarbonPHP\Interfaces\iRestNoPrimaryKey;',
                                'use CarbonPHP\Interfaces\iRestSinglePrimaryKey;'
                            ]);

                            $matches = [];

                            // the second half of this regex is from google which matches
                            if (false === preg_match_all('#\n(use (?:function)? ?(?:(?:[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff\\]*[a-zA-Z0-9_\x7f-\xff]+)|[a-zA-Z_\x80-\xff][\\\a-zA-Z0-9_\x80-\xff]+);)#i', $validation, $matches)) {
                                print 'An unexpected regex error occurred during the namespace matching/cache';
                                exit(1);
                            }

                            $userCustomImports = array_diff(
                                $matches[1],
                                $restStaticNameSpaces);


                            $rest[$tableName]['CustomImports'] = implode(PHP_EOL, $userCustomImports);

                            // methods
                            $fullTableClassName = $rest[$tableName]['namespace'] . '\\' . $rest[$tableName]['ucEachTableName'];


                            if (!class_exists($fullTableClassName)) {
                                print "We failed to load the class methods for the table '$fullTableClassName'. It was located in $targetDir, but cannot be auto-loaded. Please add the location to Composers PSR-4.\n\n";
                                exit(1);
                            }

                            $generatedClassCustomMethods = get_class_methods($fullTableClassName);

                            if ($generatedClassCustomMethods === null) {
                                print 'An unexpected error occurred when using get_class_methods.';
                                exit(1);
                            }

                            $methods = array_diff(
                                $generatedClassCustomMethods,
                                get_class_methods(Carbons::class));         // or null.. smh


                            foreach ($methods as $method) {

                                try {
                                    $func = new ReflectionMethod($fullTableClassName, $method);

                                    $comment = $func->getDocComment();

                                } catch (ReflectionException $e) {
                                    print 'Failed to load custom functions defined in restful class using ReflectionMethod.';
                                    exit(1);
                                }

                                $f = $func->getFileName();

                                $start_line = $func->getStartLine() - 1;

                                $end_line = $func->getEndLine();

                                $length = $end_line - $start_line;

                                $source = file_get_contents($f);

                                $source = preg_split('/' . PHP_EOL . '/', $source);

                                $body = implode(PHP_EOL, array_slice($source, $start_line, $length));

                                $rest[$tableName]['custom_methods'] .= ($comment ? "    $comment\n" : '') . $body . PHP_EOL . PHP_EOL;
                            }
                        }

                        if ($verbose) {
                            self::colorCode("\tGenerating {$tableName}\n", 'blue');
                            $debug and var_dump($table);
                        }
                        break;

                    case 'PRIMARY':
                        // Composite Primary Keys are a thing,  TODO - optimise the template for none vs single vs double key
                        $primary = explode('`,`', trim($words_in_insert_stmt[2], '(`),'));

                        // todo return composite primary key correctly (also, multiple auto increments a thing?)


                        foreach ($primary as $key) {
                            foreach ($rest[$tableName]['explode'] as &$value) {
                                if ($value['name'] !== $key) {
                                    continue;
                                }
                                if (true === ($value['auto_increment'] ?? false)) {
                                    $rest[$tableName]['auto_increment_return_key'] = true;
                                }
                            }
                            unset($value);
                        }

                        $rest[$tableName]['primarySort'] = implode(',', $primary);

                        // Build the insert stmt - used in put rn / exported in abstract rest
                        $sql = [];


                        foreach ($primary as $key) {
                            if (in_array($key, $binary, true)) {
                                // binary data is expected as hex @ rest call (GET,PUT,DELETE)
                                $sql[] = ' ' . $key . '=UNHEX(\'.self::addInjection($primary, $pdo).\')';
                            } else {
                                // otherwise just create the stmt normally
                                $sql[] = ' ' . $key . '=\'.self::addInjection($primary, $pdo).\'';
                            }
                            $rest[$tableName]['primary'][] = [
                                'name' => $key,
                                'binary' => in_array($key, $binary, true)
                            ];
                        }


                        $rest[$tableName]['sql'][] = ['sql' => '$sql .= \' WHERE ' . implode(' OR ', $sql) . '\';'];


                        // end - soon to deprecate todo remove
                        break;

                    case 'CONSTRAINT':

                        //  if (count($words_in_insert_stmt) !== 8) {
                        //      print  PHP_EOL . $tableName  . PHP_EOL and die;
                        //  }

                        $foreign_key = trim($words_in_insert_stmt[4], '()`');
                        $references_table = trim($words_in_insert_stmt[6], '`');
                        $references_column = trim($words_in_insert_stmt[7], '()`,');

                        if ($references_table === 'carbons' && in_array($foreign_key, $primary, true)) {
                            $rest[$tableName]['carbon_table'] = $tableName !== 'carbons';
                        }

                        // We need to catch circular dependencies as mysql dumps print schemas alphabetically
                        if (!isset($rest[$references_table])) {
                            $rest[$references_table] = ['dependencies' => []];
                        } else if (!isset($rest[$references_table]['dependencies'])) {
                            $rest[$references_table]['dependencies'] = [];
                        }

                        $verbose and self::colorCode("\nreference found ::\t$tableName([$foreign_key => $references_column])\n", 'magenta');

                        $rest[$references_table]['dependencies'][] = [$tableName => [$foreign_key => $references_column]];
                        break;


                    default:

                        if ($words_in_insert_stmt[0][0] === '`') {

                            // This is expected to be the second condition run in foreach
                            // columns is just a list of column
                            $name = $rest[$tableName]['columns'][] = trim($words_in_insert_stmt[0], '`');

                            // Explode hold all information about column
                            $rest[$tableName]['explode'][$column]['name'] = $name;
                            $rest[$tableName]['explode'][$column]['caps'] = strtoupper($name);

                            $type = strtolower($words_in_insert_stmt[1]);

                            // exploding strings like 'mediumint(9)' and 'binary(16)'
                            if (count($argv = explode('(', $type)) > 1) {
                                $type = $argv[0];
                                if ($type === 'enum') {
                                    $length = '';               // enums define strings where im expecting int length
                                } else {
                                    $length = trim($argv[1], '),');
                                }
                                // This being set determines what type of PDO stmt we use
                                $rest[$tableName]['explode'][$column]['length'] = $length;
                            }

                            $rest[$tableName]['explode'][$column]['mysql_type'] = $type;

                            $rest[$tableName]['explode'][$column]['json'] = $type === 'json';

                            // These are PDO const types, so we'll eliminate one complexity by evaluating them before inserting into the template
                            # $PDO = [0 => PDO::PARAM_NULL, 1 => PDO::PARAM_BOOL, 2 => PDO::PARAM_INT, 3 => PDO::PARAM_STR];

                            switch ($type) {                // Use pdo for what it can actually do
                                case 'bigint':
                                case 'tinyint': // @link https://stackoverflow.com/questions/12839927/mysql-tinyint-2-vs-tinyint1-what-is-the-difference
                                case 'int':
                                case 'smallint':
                                case 'mediumint':
                                    $type = 'PDO::PARAM_INT'; // $PDO[2];
                                    break;
                                case 'boolean':
                                    $type = 'PDO::PARAM_BOOL';
                                    break;
                                case 'binary':
                                    /**
                                     * looks like this wasn't needed
                                     * were using a pdo length check for varchar
                                     * and inserting a 32 char hex. The length values in
                                     * the stmt are normally 16, yet PDO does not fail.
                                     * This should be further researched
                                     **/
                                    #$length *= 2;
                                    $binary[] = $name;
                                    $rest[$tableName]['binary_trigger'][] = $name;
                                    $rest[$tableName]['binary_list'][] = ['name' => $name];
                                    $rest[$tableName]['explode'][$column]['binary'] = true;
                                    $cast_binary_default = true;
                                default:
                                case 'varchar':
                                    $type = 'PDO::PARAM_STR';
                            }
                            // Explode hold all information about column
                            $rest[$tableName]['explode'][$column]['type'] = $type;

                            // Lets check if a default value is set for column
                            $key = array_search('DEFAULT', $words_in_insert_stmt, true);

                            if ($key !== false) {
                                ++$key; // move from the word default to the default value

                                $default = '';

                                // todo - the negitive case  && substr($words_in_insert_stmt[$key], -w) === '\\\\''

                                // if it ends in '  aka '0'
                                if (substr($words_in_insert_stmt[$key], -1) === '\'') {
                                    $default = $words_in_insert_stmt[$key];
                                    // if it ends with ',  as '0',
                                } else if (substr($words_in_insert_stmt[$key], -2) === '\',') {
                                    $default = trim($words_in_insert_stmt[$key], ',');
                                    // if it doesnt start with '  as CURRENT_TIMESTAMP
                                } else if ($words_in_insert_stmt[$key][0] !== '\'') {
                                    $default = rtrim($words_in_insert_stmt[$key], ',');
                                } else { // the first index does start in ' and doesnt end in '
                                    do {
                                        if ($key > 10) {
                                            ColorCode::colorCode('Failed to understand MySQLDump File. Printing line ::');
                                            sortDump($words_in_insert_stmt);
                                        }
                                        $default .= ' ' . $words_in_insert_stmt[$key];
                                        $key++;
                                    } while (substr($words_in_insert_stmt[$key], -1) !== '\''
                                    && substr($words_in_insert_stmt[$key], -2) !== '\',');
                                    $default .= ' ' . $words_in_insert_stmt[$key];
                                    $default = trim($default, ', ');
                                }


                                if ($default === 'CURRENT_TIMESTAMP') {
                                    // Were going to skip columns with this set as the default value
                                    // Trying to insert this condition w/ PDO is problematic
                                    $skipping_col[] = $name;
                                    $rest[$tableName]['explode'][$column]['skip'] = true;
                                    $rest[$tableName]['explode'][$column]['CURRENT_TIMESTAMP'] = true;
                                } else if (strpos($default, '\'') !== 0) {
                                    // We need to escape values for php
                                    $default = "'$default'";
                                }
                                /** @noinspection NestedTernaryOperatorInspection */
                                $rest[$tableName]['explode'][$column]['default'] = ($default === "'NULL'" ? 'null' : ($cast_binary_default ? 'null' : $default));
                            }

                            // As far as I can tell the AUTO_INCREMENT condition the last possible word in the query
                            $auto_inc = count($words_in_insert_stmt) - 1;
                            if (isset($words_in_insert_stmt[$auto_inc]) && $words_in_insert_stmt[$auto_inc] === 'AUTO_INCREMENT,') {
                                $skipping_col[] = $name;
                                $rest[$tableName]['explode'][$column]['skip'] = true;
                                $rest[$tableName]['explode'][$column]['auto_increment'] = true;
                                $verbose and self::colorCode("\tThe Table '$tableName' contains an AUTO_INCREMENT column. This is bad for scaling.
                                                                        \tConsider switching to binary(16) and letting this rest API manage column uniqueness.\n", 'red');
                            }

                            $column++;
                        }
                        break;

                }
                // END SWITCH
            }
            // END PARSE

            // We need to break from this tables too if the tables is not in ( -l -f )
            if ($skipTable) {
                $skipTable = false; // This is so we can stop analysing a full tables
                continue;
            }

            $rest[$tableName]['primaryExists'] = !empty($rest[$tableName]['primary']);

            $rest[$tableName]['multiplePrimary'] = 1 < count($rest[$tableName]['primary']);


            // Make sure we didn't specify a flag that could cause us to move on...
            if (empty($rest[$tableName]['primary'])) {
                $verbose and self::colorCode("\n\nThe tables {$rest[$tableName]['TableName']} does not have a primary key.\n", iColorCode::YELLOW);
                if ($primary_required) {
                    self::colorCode(" \tSkipping...\n ",);
                    continue;
                }
            } else {
                foreach ($rest[$tableName]['explode'] as &$value) {
                    if (in_array($value, [
                        'pageSize',
                        'pageNumber'
                    ])) {
                        self::colorCode($rest[$tableName]['TableName'] . " uses reserved C6 RESTFULL keywords as a column identifier => $value\n\tRest Failed", iColorCode::RED);
                        die(1);
                    }

                    if (false !== in_array($value['name'], $primary, true)) {
                        $value['primary'] = true;
                        if (isset($value['binary'])) {
                            $value['primary_binary'] = true;
                            $rest[$tableName]['binary_primary'] = true;
                        }
                    }
                }
            }
            unset($value);

            // Listed is located in our POST method
            $rest[$tableName]['listed'] = '';
            $rest[$tableName]['implode'] = $rest[$tableName]['columns'];
            // The final value of implode is only used in the POST method
            foreach ($rest[$tableName]['implode'] as $key => &$value) {

                if (!in_array($value, $skipping_col, true)) {

                    // This suffixes an extra comma
                    $rest[$tableName]['listed'] .= $value . ', ';

                    if (in_array($value, $binary, true)) {
                        $value = ' UNHEX(:' . $value . ')';
                    } else {
                        $value = ' :' . $value;
                    }
                } else {
                    // unset($value) when &$value failed when implode became a second
                    // generation value. This doesn't seem right, (like how can this be
                    // the case?) to investigate later
                    unset($rest[$tableName]['implode'][$key]);
                }
            }
            unset($value);

            // Listed is located in our POST stmt, remove trailing comma
            $rest[$tableName]['listed'] = rtrim($rest[$tableName]['listed'], ', ');

            // Remove unneeded comma at begging of string
            $rest[$tableName]['implode'] = implode(',', $rest[$tableName]['implode']);

            $rest[$tableName]['custom_methods'] = rtrim($rest[$tableName]['custom_methods'], PHP_EOL);

            $logClasses && print $rest[$tableName]['TableName'] . ', ';

            file_put_contents($targetDir . $rest[$tableName]['ucEachTableName'] . '.php', $mustache->render($this->restTemplate(), $rest[$tableName]));
        }

        foreach ($rest as $tableName => $parsed) {
            if (empty($rest[$tableName]['explode'])) {
                self::colorCode("\nYou have a reference with wasn't resolved in the dump. Please search for '$tableName' in your "
                    . "mysqldump.sql file. This typically occurs when resolving to an outside schema, which typically indicates and error.\n", 'red');
            }
        }

        if ($react) {
            [$restAccessors, $interfaces] = $this->reactTemplate();
            $references_tsx = $interfaces_tsx = $global_column_tsx = '';
            $all_interface_types = [];
            foreach ($rest as $tableName => $parsed) {

                if (empty($rest[$tableName]['explode'])) {
                    continue;
                }


                // 'only these tables' is specified in the command line arguments (via file or comma list)
                if ($determineIfTableShouldBeSkipped($tableName) !== false) {
                    continue;
                }


                if (!class_exists($table = $rest[$tableName]['namespace'] . '\\' . $rest[$tableName]['ucEachTableName'])) {
                    self::colorCode("\n\nCouldn't locate class '$table' for react validations. This may indicate a new or unused table.\n", 'yellow');
                    continue;
                }

                if (!is_subclass_of($table, Rest::class)) {
                    continue;
                }

                $imp = array_map('strtolower', array_keys(class_implements($table)));

                if (!in_array(strtolower(iRest::class), $imp, true)
                    && !in_array(strtolower(iRestfulReferences::class), $imp, true)
                    && !in_array(strtolower(iRestMultiplePrimaryKeys::class), $imp, true)
                    && !in_array(strtolower(iRestSinglePrimaryKey::class), $imp, true)
                    && !in_array(strtolower(iRestNoPrimaryKey::class), $imp, true)
                ) {
                    continue;
                }

                if (defined("$table::REGEX_VALIDATION")) {
                    $regex_validations = constant("$table::REGEX_VALIDATION");
                    if (!is_array($regex_validations)) {
                        self::colorCode("\nRegex validations for $table must be an array!", 'red');
                        exit(1);
                    }
                    $parsed['regex_validation'] = [];

                    if (!empty($regex_validations)) {

                        $str_lreplace = static function (string $search, string $replace, string $subject) {
                            $pos = strrpos($subject, $search);

                            if ($pos !== false) {
                                $subject = substr_replace($subject, $replace, $pos, strlen($search));
                            }

                            return $subject;
                        };

                        foreach ($regex_validations as $columnName => $regex_validation) {
                            $regex_validation = $str_lreplace($regex_validation[0], '/', $regex_validation);
                            $regex_validation[0] = '/';
                            $parsed['regex_validation'][] = [
                                'name' => $columnName,
                                'validation' => $regex_validation
                            ];
                        }
                    } else {
                        $parsed['regex_validation'] = [];
                    }
                }

                $references_tsx .= PHP_EOL . $mustache->render($restAccessors, $parsed);
                $interfaces_tsx .= PHP_EOL . $mustache->render($interfaces, $parsed);
                $global_column_tsx .= PHP_EOL . $mustache->render(/** @lang Handlebars */ "{{#explode}}'{{TableName}}.{{name}}':'{{name}}',\n    {{/explode}}", $parsed);
                $all_interface_types[] = 'i' . $rest[$tableName]['ucEachTableName'];
                $all_table_names_types[] = $rest[$tableName]['TableName'];
            }


            if (empty($all_interface_types) || empty($all_table_names_types)) {
                self::colorCode('The value of $all_interface_types must not be empty. Rest Failed.', 'red');
                exit(1);
            }

            $all_interface_types = implode(' | ', $all_interface_types);

            // $all_table_names_types = implode(PHP_EOL . '" | "', $all_table_names_types);

            $export = /** @lang TypeScript JSX */
                "

export const C6 = {

    SELECT: '" . Rest::SELECT . "',
    UPDATE: '" . Rest::UPDATE . "',
    WHERE: '" . Rest::WHERE . "',
    LIMIT: '" . Rest::LIMIT . "',
    PAGINATION: '" . Rest::PAGINATION . "',
    ORDER: '" . Rest::ORDER . "',
    DESC: '" . Rest::DESC . "',
    ASC: '" . Rest::ASC . "',
    JOIN: '" . Rest::JOIN . "',
    INNER: '" . Rest::INNER . "',
    LEFT: '" . Rest::LEFT . "',
    RIGHT: '" . Rest::RIGHT . "',
    DISTINCT: '" . Rest::DISTINCT . "',
    COUNT: '" . Rest::COUNT . "',
    SUM: '" . Rest::SUM . "',
    MIN: '" . Rest::MIN . "',
    MAX: '" . Rest::MAX . "',
    GROUP_CONCAT: '" . Rest::GROUP_CONCAT . "',
    
    $references_tsx
    
};

$interfaces_tsx

export const COLUMNS = {
      $global_column_tsx
};

//export type RestTables = \"\$all_table_names_types\";

export type RestTableInterfaces = $all_interface_types;

export const convertForRequestBody = function(restfulObject: RestTableInterfaces, tableName: string) {
  let payload = {};
  Object.keys(restfulObject).map(value => {
    let exactReference = value.toUpperCase();
    if (exactReference in C6[tableName]) {
      payload[C6[tableName][exactReference]] = restfulObject[value]
    }
    return true;
  });
  return payload;
};

";
            file_put_contents($react . 'C6.tsx', $export);


            if ($javascriptBindings) {
                $export = /** @lang TypeScript JSX */
                    "

const C6 = {

    SELECT: '" . Rest::SELECT . "',
    UPDATE: '" . Rest::UPDATE . "',
    WHERE: '" . Rest::WHERE . "',
    LIMIT: '" . Rest::LIMIT . "',
    PAGINATION: '" . Rest::PAGINATION . "',
    ORDER: '" . Rest::ORDER . "',
    DESC: '" . Rest::DESC . "',
    ASC: '" . Rest::ASC . "',
    JOIN: '" . Rest::JOIN . "',
    INNER: '" . Rest::INNER . "',
    LEFT: '" . Rest::LEFT . "',
    RIGHT: '" . Rest::RIGHT . "',
    DISTINCT: '" . Rest::DISTINCT . "',
    COUNT: '" . Rest::COUNT . "',
    SUM: '" . Rest::SUM . "',
    MIN: '" . Rest::MIN . "',
    MAX: '" . Rest::MAX . "',
    GROUP_CONCAT: '" . Rest::GROUP_CONCAT . "',
    
    $references_tsx
    
};

const COLUMNS = {
      $global_column_tsx
};

const convertForRequestBody = function(restfulObject, tableName) {
  let payload = {};
  Object.keys(restfulObject).map(value => {
    let exactReference = value.toUpperCase();
    if (exactReference in C6[tableName]) {
      payload[C6[tableName][exactReference]] = restfulObject[value]
    }
    return true;
  });
  return payload;
};

";
                file_put_contents($javascriptBindings . 'C6.js', $export);

            }


        }

        // todo - log classes
        $logClasses && print "\n";

        self::colorCode("\tFinished Building REST ORM!\n\n");


        // TODO - validate the methods defined in table space

        /**
         * Now that the full dump has been parsed, we need to build our triggers
         * using the foreign key analysis
         */

        if ($history_table_query) {
            print "\tBuilding Triggers!\n";

            $triggers = '';
            foreach ($rest as $table) {
                if (in_array($table['TableName'], ['sys_resource_creation_logs', 'sys_resource_history_logs'])) {
                    continue;
                }
                if ($table['binary_primary'] && ($only_these_tables === null || in_array($table['TableName'], $only_these_tables, true))) {
                    $triggers .= self::trigger($table['TableName'], $table['columns'], $table['binary_trigger'] ?? [], $table['dependencies'], $table['primary'][0]['name']);
                }
            }

            file_put_contents('triggers.sql', 'DELIMITER ;;' . PHP_EOL . $triggers . PHP_EOL . 'DELIMITER ;');

            $this->MySQLSource( 'triggers.sql', $mysql ?? null);
        }

        // debug is a subset of the verbose flag
        /** @noinspection ForgottenDebugOutputInspection */
        $debug and var_dump($rest['clients']);

        self::colorCode("\tSuccess!\n\n");
        print "\n\nSuccess\n";

    }

    /**
     * @param $table
     * @param $columns
     * @param $binary
     * @param $dependencies
     * @param $primary
     * @return string
     */
    public static function trigger($table, $columns, $binary, $dependencies, $primary): string
    {
        $json_mysql = static function ($op = 'NEW') use ($columns, $binary) {
            $mid = "DECLARE json text;\n SET json = '{';";
            foreach ($columns as $key => &$column) {
                $column = in_array($column, $binary, true)
                    ? <<<END
                        \nSET json = CONCAT(json,'"$column":"', HEX($op.$column), '"');
                        END
                    : <<<END
                        \nSET json = CONCAT(json,'"$column":"', COALESCE($op.$column,''), '"');
                        END;
            }
            unset($column);

            $mid .= implode("\nSET json = CONCAT(json, ',');", $columns);

            $mid .= <<<END
                SET json = CONCAT(json, '}');
                END;

            return $mid;
        };

        // sys_resource_creation_logs sys_resource_history_logs

        $history_sql = static function ($operation_type = 'POST') use ($table, $primary) {
            $query = '';
            $relative_time = $operation_type === 'POST' ? 'NEW' : ($operation_type === 'PUT' ? 'NEW' : 'OLD');
            switch ($operation_type) {
                case 'POST':
                    // todo - triggers? logs? idk.. i dont remember
                    /** @noinspection SqlResolve */
                    $query = "INSERT INTO carbon_creation_logs (`uuid`, `resource_type`, `resource_uuid`)
            VALUES (UNHEX(REPLACE(UUID() COLLATE utf8_unicode_ci,'-','')), '$table', $relative_time.$primary);\n";
                case 'PUT':
                case 'DELETE':
                    /** @noinspection SqlResolve */
                    $query .= "INSERT INTO carbon_history_logs (`uuid`, `resource_type`, `resource_uuid`, `operation_type`, `data`)
            VALUES (UNHEX(REPLACE(UUID() COLLATE utf8_unicode_ci,'-','')), '$table', $relative_time.$primary , '$operation_type', json);";
                    break;
                case 'GET':
                default:
                    break;
            }

            return $query;
        };

        $delete_children = static function () use ($dependencies) {
            $sql = '';
            if (!empty($dependencies)) {
                foreach ($dependencies as $array) {
                    foreach ($array as $child => $relation) {
                        foreach ($relation as $c => $keys) {
                            /** @noinspection SqlResolve */
                            $sql .= "DELETE FROM $child WHERE $c = OLD.$keys;" . PHP_EOL;
                        }
                    }
                }
            }
            return $sql;
        };

        return <<<TRIGGER
DROP TRIGGER IF EXISTS `trigger_{$table}_b_d`;;
CREATE TRIGGER `trigger_{$table}_b_d` BEFORE DELETE ON `$table` FOR EACH ROW
BEGIN
{$json_mysql('OLD')}
      -- Insert record into audit tables
{$history_sql('DELETE')}
      -- Delete Children
{$delete_children()}

END;;

DROP TRIGGER IF EXISTS `trigger_{$table}_a_u`;;
CREATE TRIGGER `trigger_{$table}_a_u` AFTER UPDATE ON `$table` FOR EACH ROW
BEGIN

{$json_mysql()}
      -- Insert record into audit tables
{$history_sql('PUT')}

END;;

DROP TRIGGER IF EXISTS `trigger_{$table}_a_i`;;
CREATE TRIGGER `trigger_{$table}_a_i` AFTER INSERT ON `$table` FOR EACH ROW
BEGIN

{$json_mysql()}
      -- Insert record into audit tables
{$history_sql('POST')}

END;;
TRIGGER;
    }

    /**
     * @return array
     */
    private function reactTemplate(): array
    {
        return [/** @lang Handlebars */ "
  {{strtolowerNoPrefixTableName}}: {
    TABLE_NAME:'{{strtolowerNoPrefixTableName}}',
    {{#explode}}
    {{caps}}: '{{TableName}}.{{name}}',
    {{/explode}}
    PRIMARY: [
        {{#primary}}{{#name}}'{{TableName}}.{{name}}',{{/name}}
        {{/primary}}
    ],
    COLUMNS: {
      {{#explode}}'{{TableName}}.{{name}}':'{{name}}',
      {{/explode}}
    },
    REGEX_VALIDATION: {
        {{#regex_validation}}
        '{{name}}': {{validation}},
        {{/regex_validation}}
    }

  },", /** @lang Handlebars */ "
export interface  i{{ucEachTableName}}{
      {{#explode}}'{{name}}'?: string;
      {{/explode}}
}
  "];
    }


    private function restTemplateStaticNameSpace(): array
    {
        return [
            'use CarbonPHP\Database;',
            'use CarbonPHP\Error\PublicAlert;',
            'use CarbonPHP\Helpers\RestfulValidations;',
            'use CarbonPHP\Rest;',
            'use JsonException;',
            'use PDO;',
            'use PDOException;',
            'use function array_key_exists;',
            'use function count;',
            'use function func_get_args;',
            'use function is_array;'
        ];
    }

    private function restTemplate(): string
    {
        $staticNamespaces = $this->restTemplateStaticNameSpace();

        $interface = /** @lang Handlebars */
            '{{#primaryExists}}{{#multiplePrimary}}iRestMultiplePrimaryKeys{{/multiplePrimary}}{{^multiplePrimary}}iRestSinglePrimaryKey{{/multiplePrimary}}{{/primaryExists}}{{^primaryExists}}iRestNoPrimaryKey{{/primaryExists}}';

        array_splice($staticNamespaces, 2, 0, [
            "use CarbonPHP\Interfaces\\$interface;",
        ]);

        $staticNamespaces = implode(PHP_EOL, $staticNamespaces);

        return /** @lang Handlebars */ <<<STRING
<?php /** @noinspection DuplicatedCode */

namespace {{namespace}};

// Restful defaults
$staticNamespaces

// Custom User Imports
{{#CustomImports}}{{{CustomImports}}}{{/CustomImports}}

/**
 *
 * Class {{ucEachTableName}}
 * @package {{namespace}}
 * @note Note for convenience, a flag '-prefix' maybe passed to remove table prefixes.
 *  Use '-help' for a full list of options.
 * @link https://carbonphp.com/ 
 *
 * This class contains autogenerated code.
 * This class is a 1=1 relation named after a table in the database schema provided to the program `RestBuilder`.
 * Your edits are preserved during updates given they follow::
 *      METHODS SHOULD ONLY BE STATIC and may be reordered during generation.
 *      FUNCTIONS MUST NOT EXIST outside the class. (methods and functions are not the same.)
 *      IMPORTED CLASSED AND FUNCTIONS ARE ALLOWED though maybe reordered.
 *      ADDITIONAL CONSTANTS of any kind ARE NOT ALLOWED.
 *      ADDITIONAL CLASS MEMBER VARIABLES are NOT ALLOWED.
 *
 * When creating static member functions which require persistent variables, consider making them static members of that 
 *  static method.
 */
class {{ucEachTableName}} extends Rest implements {{#primaryExists}}{{#multiplePrimary}}iRestMultiplePrimaryKeys{{/multiplePrimary}}{{^multiplePrimary}}iRestSinglePrimaryKey{{/multiplePrimary}}{{/primaryExists}}{{^primaryExists}}iRestNoPrimaryKey{{/primaryExists}}
{
    use RestfulValidations;
    
    public const CLASS_NAME = '{{ucEachTableName}}';
    public const CLASS_NAMESPACE = '{{namespace}}\\\\';
    public const TABLE_NAME = '{{TableName}}';
    public const TABLE_PREFIX = {{#prefixReplaced}}'{{prefix}}'{{/prefixReplaced}}{{^prefixReplaced}}''{{/prefixReplaced}};
    
    /**
     * COLUMNS
     * The columns below are a 1=1 mapping to the columns found in {{TableName}}. 
     * Changes, shuch as adding or removing a column, SHOULD be made first in the database. The RestBuilder program will 
     * capture any changes made in MySQL and update this file auto-magically. 
    **/{{#explode}}
    public const {{caps}} = '{{TableName}}.{{name}}'; 
    {{/explode}}

    /**
     * PRIMARY
     * This could be null for tables without primary key(s), a string for tables with a single primary key, or an array 
     * given composite primary keys. The existence and amount of primary keys of the will also determine the interface 
     * aka method signatures used.
    **/
    public const PRIMARY = {{^primaryExists}}null{{/primaryExists}}{{#primaryExists}}{{#multiplePrimary}}[{{#primary}}{{#name}}'{{TableName}}.{{name}}',{{/name}}{{/primary}}
    ]{{/multiplePrimary}}{{^multiplePrimary}}{{#primary}}'{{TableName}}.{{name}}'{{/primary}}{{/multiplePrimary}}{{/primaryExists}};

    /**
     * COLUMNS
     * This is a convience constant for accessing your data after it has be returned from a rest operation. It is needed
     * as Mysql will strip away the tablename we have explicitly provided to each column (to help with join statments).
     * Thus, accessing your return values might look something like:
     *      \$return[self::COLUMNS[self::EXAMPLE_COLUMN_ONE]]
    **/ 
    public const COLUMNS = [
        {{#explode}}'{{TableName}}.{{name}}' => '{{name}}',{{/explode}}
    ];

    public const PDO_VALIDATION = [
        {{#explode}}'{{TableName}}.{{name}}' => ['{{mysql_type}}', '{{type}}', '{{length}}'],{{/explode}}
    ];
     
    /**
     * REFRESH_SCHEMA
     * These directives should be designed to maintain and update your team's schema &| database &| table over time. 
     * It is RECOMMENDED that ALL changes you make in your local env be programmatically coded out in callables such as 
     * the 'tableExistsOrExecuteSQL' method call below. If a PDO exception is thrown with `\$e->getCode()` equal to 42S02 
     * or 1049 CarbonPHP will attempt to REFRESH the full database with with all directives in all tables. If possible 
     * keep table specific procedures in it's respective restful-class table file. Check out the 'tableExistsOrExecuteSQL' 
     * method in the parent class to see a more abstract procedure.
     * Each directive MUST be designed to run multiple times without failure.
     */{{^REFRESH_SCHEMA}}
    public const REFRESH_SCHEMA = [
        [self::class => 'tableExistsOrExecuteSQL', self::TABLE_NAME, self::REMOVE_MYSQL_FOREIGN_KEY_CHECKS .
                        PHP_EOL . self::CREATE_TABLE_SQL . PHP_EOL . self::REVERT_MYSQL_FOREIGN_KEY_CHECKS]
    ];{{/REFRESH_SCHEMA}}{{#REFRESH_SCHEMA}}
    {{{REFRESH_SCHEMA}}} 
    {{/REFRESH_SCHEMA}}
    
    /**
     * REGEX_VALIDATION
     * Regular Expression validations will run before and recommended over PHP_VALIDATION.
     * It is a 1 to 1 column regex relation with fully regex for preg_match_all(). This regex must satisfy the condition 
     *        1 > preg_match_all(self::\$compiled_regex_validations[\$column], \$value, ...
     * 
     * Table generated column constants must be used. 
     *       self::EXAMPLE_COLUMN_NAME => '#^[A-F0-9]{20,35}$#i'
     *
     * @link https://regexr.com
     * @link https://php.net/manual/en/function.preg-match-all.php
     */{{^regex_validation}}
    public const REGEX_VALIDATION = [];{{/regex_validation}}{{#regex_validation}}
    {{{regex_validation}}} 
    {{/regex_validation}}     
     
     
    /**
     * PHP_VALIDATION
     * PHP validations works as follows:
     * @note regex validation is always step #1 and should be favored over php validations.
     *  Syntax ::
     *      [Example_Class::class => 'disallowPublicAccess', (optional) ...\$rest]
     *      self::EXAMPLE_COLUMN => [Example_Class::class => 'exampleOtherMethod', (optional) ...\$rest]
     *
     *  Callables defined above MUST NOT RETURN FALSE. Moreover; return values are ignored so `): void {` may be used. 
     *  array_key_first() must return a fully qualified class namespace. In the example above Example_Class would be a
     *  class defined in our system. PHP's `::class` appended to the end will return the fully qualified namespace. Note
     *  this will require the custom import added to the top of the file. You can allow your editor to add these for you
     *  as the RestBuilder program will capture, preserve, and possibly reorder the imports. The value of the first key 
     *  MUST BE the exact name of a member-method of that class. Typically validations are defined in the same class 
     *  they are used ('self::class') though it is useful to export more dynamic functions. The \$rest variable can be 
     *  used to add additional arguments to the request. RESTFUL INTERNAL ARGUMENTS will be passed before any use defined
     *  variables after the first key value pair. Only array values will be passed to the method. Thus, additional keys 
     *  listed in the array will be ignored. Take for example::
     *
     *      [ self::class => 'validateUnique', self::class, self::EXAMPLE_COLUMN]
     *  The above is defined in RestfulValidations::class. 
     *      RestfulValidations::validateUnique(string \$columnValue, string \$className, string \$columnName)
     *  Its definition is with a trait this classes inherits using `use` just after the `class` keyword. 
     * 
     *   What is the RESTFUL lifecycle?
     *      Regex validations are done first on any main query; sub-queries are treated like callbacks which get run 
     *      during the main queries invocation. The main query is 'paused' while the sub-query will compile and validate.
     *      Validations across tables are concatenated on joins and sub-queries. All callbacks will be run across any 
     *       table joins.
     *      
     *   What are the RESTFUL INTERNAL ARGUMENTS? (The single \$arg string or array passed before my own...)
     *      REST_REQUEST_PREPROCESS_CALLBACKS ::   
     *           PREPROCESS::
     *              Methods defined here will be called at the beginning of every request. 
     *              Each method will be passed ( & self::\$REST_REQUEST_PARAMETERS ) by reference so changes can be made pre-request.
     *              Method validations under the main 'PREPROCESS' key will be run first, while validations specific to 
     *              ( GET | POST | PUT | DELETE )::PREPROCESS will be run directly after.
     *
     *           FINAL:: 
     *              Each method will be passed the final ( & \$SQL ), which may be a sub-query, by reference.
     *              Modifying the SQL string will effect the parent function. This can have disastrous effects.
     *
     *           COLUMN::
     *              Preformed while a column is being parsed in a query. The first column validations to run.
     *              Each column specific method under PREPROCESS will be passed nothing from rest. 
     *              Each method will ONLY be RUN ONCE regardless of how many times the column has been seen. 
     *
     *      COLUMN::
     *           Column validations are only run when they have been parsed in the query. Global column validations maybe
     *            RUN MULTIPLE TIMES if the column is used multiple times in a single restful query. 
     *           If you have a column that is used multiple times the validations will run for each occurrence.
     *           Column validation can mean many thing. There are three possible scenarios in which your method 
     *            signature would change. For this reason it is more common to use method ( GET | POST ... ) wise column validations.
     *              *The signature required are as follows:
     *                  Should the column be...
     *                      SELECTED:  
     *                          In a select stmt no additional parameters will be passed.
     *                      
     *                      ORDERED BY: (self::ASC | self::DESC)
     *                          The \$operator will be passed to the method.
     *  
     *                      JOIN STMT:
     *                          The \$operator followed by the \$value will be passed. 
     *                          The operator could be :: >,<,<=,<,=,<>,=,<=>
     *
     *      REST_REQUEST_FINNISH_CALLBACKS::
     *          PREPROCESS::
     *              These callbacks are called after a successful PDOStatement->execute() but before Database::commit().
     *              Each method will be passed ( GET => &\$return, DELETE => &\$remove, PUT => &\$returnUpdated ) by reference. 
     *              POST will BE PASSED NULL.          
     *
     *          FINAL::
     *              Run directly after method specific [FINAL] callbacks.
     *              The final, 'final' callback set. After these run rest will return. 
     *              Each method will be passed ( GET => &\$return, DELETE => &\$remove, PUT => &\$returnUpdated ) by reference. 
     *              POST will BE PASSED NULL. 
     *
     *          COLUMN::
     *              These callables will be run after the [( GET | POST | PUT | DELETE )][FINAL] methods.
     *              Directly after, the [REST_REQUEST_FINNISH_CALLBACKS][FINAL] will run. 
     *              
     *
     *      (POST|GET|PUT|DELETE)::
     *          PREPROCESS::
     *              Methods run after any root 'REST_REQUEST_PREPROCESS_CALLBACKS'
     *              Each method will not be passed any argument from system. User arguments will be directly reflected.
     *
     *          COLUMN::
     *              Methods run after any root column validations, the last of the PREPROCESS column validations to run.
     *              Based on the existences and number of primary key(s), the signature will change. 
     *               See the notes on the base column validations as signature of parameters may change. 
     *              It is not possible to directly define a method->column specific post processes. This can be done by
     *               dynamically pairing multiple method processes starting with one here which signals a code routine 
     *               in a `finial`-ly defined method. The FINAL block specific to the method would suffice. 
     *
     *          FINAL::
     *              Passed the ( & \$return )  
     *              Run before any other column validation 
     *
     *  Be aware the const: self::DISALLOW_PUBLIC_ACCESS = [self::class => 'disallowPublicAccess'];
     *  could be used to replace each occurrence of 
     *          [self::class => 'disallowPublicAccess', self::class]
     *  though would loose information as self::class is a dynamic variable which must be used in this class given 
     *  static and constant context. 
     *  @version ^9
     */
    {{^php_validation}}
    public const PHP_VALIDATION = [ 
        self::REST_REQUEST_PREPROCESS_CALLBACKS => [ 
            self::PREPROCESS => [ 
                [self::class => 'disallowPublicAccess', self::class],
            ]
        ],
        self::GET => [ 
            self::PREPROCESS => [ 
                [self::class => 'disallowPublicAccess', self::class],
            ]
        ],    
        self::POST => [ self::PREPROCESS => [[ self::class => 'disallowPublicAccess', self::class ]]],    
        self::PUT => [ self::PREPROCESS => [[ self::class => 'disallowPublicAccess', self::class ]]],    
        self::DELETE => [ self::PREPROCESS => [[ self::class => 'disallowPublicAccess', self::class ]]],
        self::REST_REQUEST_FINNISH_CALLBACKS => [ self::PREPROCESS => [[ self::class => 'disallowPublicAccess', self::class ]]]    
    ];{{/php_validation}} 
    {{#php_validation}} 
    {{{php_validation}}} 
    {{/php_validation}}
   
    /**
     * CREATE_TABLE_SQL is autogenerated and should not be manually updated. Make changes in MySQL and regenerate using
     * the RestBuilder program.
     */
    public const CREATE_TABLE_SQL = /** @lang MySQL */ <<<MYSQL
    {{createTableSQL}}
MYSQL;
   
   
{{{custom_methods}}}
    
    /**
     * @deprecated Use the class constant CREATE_TABLE_SQL directly
     * @return string
     */
    public static function createTableSQL() : string {
        return self::CREATE_TABLE_SQL;
    }
    
    /**
    * Currently nested aggregation is not supported. It is recommended to avoid using 'AS' where possible. Sub-selects are 
    * allowed and do support 'as' aggregation. Refer to the static subSelect method parameters in the parent `Rest` class.
    * All supported aggregation is listed in the example below. Note while the WHERE and JOIN members are syntactically 
    * similar, and are moreover compiled through the same method, our aggregation is not. Please refer to this example 
    * when building your queries. By design, queries using subSelect are only allowed internally. Public Sub-Selects may 
    * be given an optional argument with future releases but will never default to on. Thus, you external API validation
    * need only validate for possible table joins. In many cases sub-selects can be replaces using simple joins, this is
    * highly recommended.
    *
    *   \$argv = [
    *       Rest::SELECT => [
    *              'table_name.column_name',                            // bad, dont pass strings manually. Use Table Constants instead.
    *              self::EXAMPLE_COLUMN_ONE,                            // good, 
    *              [self::EXAMPLE_COLUMN_TWO, Rest::AS, 'customName'],
    *              [Rest::COUNT, self::EXAMPLE_COLUMN_TWO, 'custom_return_name_using_as'],
    *              [Rest::GROUP_CONCAT, self::EXAMPLE_COLUMN_THREE], 
    *              [Rest::MAX, self::EXAMPLE_COLUMN_FOUR], 
    *              [Rest::MIN, self::EXAMPLE_COLUMN_FIVE], 
    *              [Rest::SUM, self::EXAMPLE_COLUMN_SIX], 
    *              [Rest::DISTINCT, self::EXAMPLE_COLUMN_SEVEN], 
    *              ANOTHER_EXAMPLE_TABLE::subSelect(\$primary, \$argv, \$as, \$pdo, \$database)
    *       ],
    *       Rest::WHERE => [
    *              
    *              self::EXAMPLE_COLUMN_NINE => 'Value To Constrain',                       // self::EXAMPLE_COLUMN_NINE AND           
    *              'Defaults to boolean AND grouping' => 'Nesting array switches to OR',    // ''='' AND 
    *              [
    *                  'Column Name' => 'Value To Constrain',                                  // ''='' OR
    *                  'This array is OR'ed together' => 'Another sud array would `AND`'       // ''=''
    *                  [ etc... ]
    *              ],
    *              'last' => 'whereExample'                                                  // AND '' = ''
    *        ],
    *        Rest::JOIN => [
    *            Rest::INNER => [
    *                Carbon_Users::CLASS_NAME => [
    *                    'Column Name' => 'Value To Constrain',
    *                    'Defaults to AND' => 'Nesting array switches to OR',
    *                    [
    *                       'Column Name' => 'Value To Constrain',
    *                       'This array is OR'ed together' => 'value'
    *                       [ 'Another sud array would `AND`ed... ]
    *                    ],
    *                    [ 'Column Name', Rest::LESS_THAN, 'Another Column Name']           // NOTE the Rest::LESS_THAN
    *                ]
    *            ],
    *            Rest::LEFT_OUTER => [
    *                Example_Table::CLASS_NAME => [
    *                    Location::USER_ID => Users::ID,
    *                    Location_References::ENTITY_KEY => \$custom_var,
    *                   
    *                ],
    *                Example_Table_Two::CLASS_NAME => [
    *                    Example_Table_Two::ID => Example_Table_Two::subSelect(\$primary, \$argv, \$as, \$pdo, \$database)
    *                    ect... 
    *                ]
    *            ]
    *        ],
    *        Rest::PAGINATION => [
    *              Rest::PAGE => (int) 0, // used for pagination which equates to 
    *                  // ... LIMIT ' . ((\$argv[self::PAGINATION][self::PAGE] - 1) * \$argv[self::PAGINATION][self::LIMIT]) 
    *                  //       . ',' . \$argv[self::PAGINATION][self::LIMIT];
    *              
    *              Rest::LIMIT => (int) 90, // The maximum number of rows to return,
    *                       setting the limit explicitly to 1 will return a key pair array of only the
    *                       singular result. SETTING THE LIMIT TO NULL WILL ALLOW INFINITE RESULTS (NO LIMIT).
    *                       The limit defaults to 100 by design.
    *
    *               Rest::ORDER => [self::EXAMPLE_COLUMN_TEN => Rest::ASC ],  // i.e.  'username' => Rest::DESC
    *         ],
    *   ];
    *
    *
    * @param array \$return{{#primaryExists}}
    * @param {{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}}|null \$primary{{/primaryExists}}
    * @param array \$argv
    * @noinspection DuplicatedCode - possible as this is generated
    * @generated
    * @throws PublicAlert|PDOException|JsonException
    * @return bool
    */
    public static function Get(array &\$return, {{#primaryExists}}{{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}} \$primary = null, {{/primaryExists}}array \$argv = []): bool
    {
        self::startRest(self::GET, \$return, \$argv {{#primaryExists}},\$primary{{/primaryExists}});

        \$pdo = self::database();

        \$sql = self::buildSelectQuery({{#primaryExists}}\$primary{{/primaryExists}}{{^primaryExists}}null{{/primaryExists}}, \$argv, {{^carbon_namespace}}{{#QueryWithDatabaseName}}'{{database}}'{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{^QueryWithDatabaseName}}''{{/QueryWithDatabaseName}}{{#carbon_namespace}}''{{/carbon_namespace}}, \$pdo);{{#json}}
        
        self::jsonSQLReporting(func_get_args(), \$sql);{{/json}}
        
        self::postpreprocessRestRequest(\$sql);
        
        \$stmt = \$pdo->prepare(\$sql);

        self::bind(\$stmt);

        if (!\$stmt->execute()) {
            self::completeRest();
            return self::signalError('The REST generated PDOStatement failed to execute with error :: ' . json_encode(\$stmt->errorInfo(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT));
        }

        \$return = \$stmt->fetchAll(PDO::FETCH_ASSOC);{{#primaryExists}}{{#sql}}
        
        if ((null !== \$primary && {{^multiplePrimary}}''{{/multiplePrimary}}{{#multiplePrimary}}[]{{/multiplePrimary}} !== \$primary) || (isset(\$argv[self::PAGINATION][self::LIMIT]) && \$argv[self::PAGINATION][self::LIMIT] === 1 && count(\$return) === 1)) {
            \$return = isset(\$return[0]) && is_array(\$return[0]) ? \$return[0] : \$return;
        }{{/sql}}{{/primaryExists}}{{^primary}}
        
        if (isset(\$argv[self::PAGINATION][self::LIMIT]) && \$argv[self::PAGINATION][self::LIMIT] === 1 && count(\$return) === 1) {
            \$return = isset(\$return[0]) && is_array(\$return[0]) ? \$return[0] : \$return;
        }{{/primary}}{{#explode}}{{#json}}
        
        if (array_key_exists('{{name}}', \$return)) {
                \$return['{{name}}'] = json_decode(\$return['{{name}}'], true);
        }{{/json}}{{/explode}}

        self::postprocessRestRequest(\$return);
        
        self::completeRest();
        
        return true;
    }

    /**
     * @param array \$data 
     * @return bool|string{{#primaryExists}}|mixed{{/primaryExists}}
     * @generated
     * @throws PublicAlert|PDOException|JsonException
     */
    public static function Post(array \$data = []){{^primaryExists}}: bool{{/primaryExists}}
    {   
        self::startRest(self::POST, [], \$data);
    
        foreach (\$data as \$columnName => \$postValue) {
            if (!array_key_exists(\$columnName, self::PDO_VALIDATION)) {
                return self::signalError("Restful table could not post column \$columnName, because it does not appear to exist.");
            }
        } 
        
        \$sql = 'INSERT INTO {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{TableName}} ({{listed}}) VALUES ({{{implode}}})';

        {{^binary_primary}}
        \$pdo = self::database();
        
        if (!\$pdo->inTransaction()) {
            \$pdo->beginTransaction();
        }
        {{/binary_primary}}

        {{#json}}self::jsonSQLReporting(func_get_args(), \$sql);{{/json}}

        self::postpreprocessRestRequest(\$sql);

        \$stmt = self::database()->prepare(\$sql);
        {{#explode}}{{#primary_binary}}{{^carbon_table}}
        \${{name}} = \$id = \$data['{{TableName}}.{{name}}'] ?? false;
        if (\$id === false) {
             \${{name}} = \$id = self::fetchColumn('SELECT (REPLACE(UUID() COLLATE utf8_unicode_ci,"-",""))')[0];
        } else {
            \$ref='{{TableName}}.{{name}}';
            \$op = self::EQUAL;
            if (!self::validateInternalColumn(self::POST, \$ref, \$op, \${{name}})) {
                return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
            }            
        }
        \$stmt->bindParam(':{{name}}',\${{name}}, {{type}}, {{length}});
        {{/carbon_table}}{{#carbon_table}}
        \${{name}} = \$id = \$data['{{TableName}}.{{name}}'] ?? false;
        if (\$id === false) {
            \${{name}} = \$id = self::beginTransaction(self::class, \$data[self::DEPENDANT_ON_ENTITY] ?? null);
        } else {
            \$ref='{{TableName}}.{{name}}';
            \$op = self::EQUAL;
            if (!self::validateInternalColumn(self::POST, \$ref, \$op, \${{name}})) {
                return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
            }            
        }
        \$stmt->bindParam(':{{name}}',\${{name}}, {{type}}, {{length}});
        {{/carbon_table}}{{/primary_binary}}{{^primary_binary}}{{#skip}}{{#CURRENT_TIMESTAMP}}
        if (array_key_exists('{{TableName}}.{{name}}', \$data)) {
            return self::signalError('The column \'{{TableName}}.{{name}}\' is set to default to CURRENT_TIMESTAMP. The Rest API does not allow POST requests with columns explicitly set whose default is CURRENT_TIMESTAMP. You can remove to the default in MySQL or the column \'{{TableName}}.{{name}}\' from the request.');
        }
        {{/CURRENT_TIMESTAMP}}{{/skip}}{{^skip}}{{^length}}{{#json}}
        if (!array_key_exists('{{TableName}}.{{name}}', \$data)) {
            return self::signalError('The column \'{{TableName}}.{{name}}\' is set to not null and has no default value. It must exist in the request and was not found in the one sent.');
        }
        \$ref = '{{TableName}}.{{name}}';
        \$op = self::EQUAL;
        if (!self::validateInternalColumn(self::POST, \$ref, \$op, \$data['{{name}}'])) {
            return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
        }
        if (!is_string(\${{name}} = \$data['{{TableName}}.{{name}}']) && false === \${{name}} = json_encode(\${{name}})) {
            return self::signalError('The column \'{{TableName}}.{{name}}\' failed to be json encoded.');
        }
        \$stmt->bindValue(':{{name}}', \${{name}}, {{type}});
        {{/json}}{{^json}}{{^default}}
        if (!array_key_exists('{{TableName}}.{{name}}', \$data)) {
            return self::signalError('The column \'{{TableName}}.{{name}}\' is set to not null and has no default value. It must exist in the request and was not found in the one sent.');
        } 
        \$ref='{{TableName}}.{{name}}';
        \$op = self::EQUAL;
        if (!self::validateInternalColumn(self::POST, \$ref, \$op, \$data['{{name}}'])) {
            return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
        }
        \$stmt->bindValue(':{{name}}', \$data['{{TableName}}.{{name}}'], {{type}});
        {{/default}}{{#default}}         
        \${{name}} = \$data['{{TableName}}.{{name}}'] ?? {{default}};
        \$ref='{{TableName}}.{{name}}';
        \$op = self::EQUAL;
        if (!self::validateInternalColumn(self::POST, \$ref, \$op, \${{name}}, \${{name}} === {{{default}}})) {
            return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
        }
        \$stmt->bindValue(':{{name}}', \${{name}}, {{type}});
        {{/default}}{{/json}}{{/length}}{{#length}}{{^default}}
        if (!array_key_exists('{{TableName}}.{{name}}', \$data)) {
            return self::signalError('Required argument "{{TableName}}.{{name}}" is missing from the request.');
        }{{/default}}
        \${{name}} = {{^default}}\$data['{{TableName}}.{{name}}'];{{/default}}{{#default}}\$data['{{TableName}}.{{name}}'] ?? {{{default}}};{{/default}}
        \$ref='{{TableName}}.{{name}}';
        \$op = self::EQUAL;
        if (!self::validateInternalColumn(self::POST, \$ref, \$op, \${{name}}{{#default}}, \${{name}} === {{{default}}}{{/default}})) {
            return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
        }
        \$stmt->bindParam(':{{name}}',\${{name}}, {{type}}, {{length}});
        {{/length}}{{/skip}}{{/primary_binary}}{{/explode}}
        if (!\$stmt->execute()) {
            self::completeRest();
            return self::signalError('The REST generated PDOStatement failed to execute with error :: ' . json_encode(\$stmt->errorInfo(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT));
        }{{#binary_primary}}
        
        self::prepostprocessRestRequest(\$id);
         
        if (self::\$commit && !Database::commit()) {
           return self::signalError('Failed to store commit transaction on table {{TableName}}');
        } 
         
        self::postprocessRestRequest(\$id); 
         
        self::completeRest();
        
        return \$id; 
        {{/binary_primary}}{{^binary_primary}}{{#auto_increment_return_key}}
        
        \$id = \$pdo->lastInsertId();{{/auto_increment_return_key}}
        
        self::prepostprocessRestRequest({{#auto_increment_return_key}}\$id{{/auto_increment_return_key}});
        
        if (self::\$commit && !Database::commit()) {
            return self::signalError('Failed to store commit transaction on table {{TableName}}');
        }
        
        self::postprocessRestRequest({{#auto_increment_return_key}}\$id{{/auto_increment_return_key}});
        
        self::completeRest();
        
        return {{^auto_increment_return_key}}true{{/auto_increment_return_key}}{{#auto_increment_return_key}}\$id{{/auto_increment_return_key}};  {{/binary_primary}}
    }
    
    /**
    * 
    * {{^primaryExists}}
    *  Syntax should be as follows.
    *  \$argv = [
    *       Rest::UPDATE => [
    *              ...
    *       ],
    *       Rest::WHERE => [
    *              ...
    *       ]
    * {{/primaryExists}}{{#primaryExists}}
    * Tables where primary keys exist must be updated by its primary key. 
    * Column should be in a key value pair passed to \$argv or optionally using syntax:
    * \$argv = [
    *       Rest::UPDATE => [
    *              ...
    *       ]
    * ]
    * {{/primaryExists}}
    * @param array \$returnUpdated - will be merged with with array_merge, with a successful update. 
    {{#primaryExists}}* @param {{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}}|null \$primary{{/primaryExists}}
    * @param array \$argv 
    * @generated
    * @throws PublicAlert|PDOException|JsonException
    * @return bool - if execute fails, false will be returned and \$returnUpdated = \$stmt->errorInfo(); 
    */
    public static function Put(array &\$returnUpdated, {{#primaryExists}}{{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}} \$primary = null,{{/primaryExists}} array \$argv = []) : bool
    {
        self::startRest(self::PUT, \$returnUpdated, \$argv{{#primaryExists}}, \$primary{{/primaryExists}});
        
        \$where = [];

        if (array_key_exists(self::WHERE, \$argv)) {
            \$where = \$argv[self::WHERE];
            unset(\$argv[self::WHERE]);
        }
        
        if (array_key_exists(self::UPDATE, \$argv)) {
            \$argv = \$argv[self::UPDATE];
        }{{#primaryExists}}
        
        \$emptyPrimary = null === \$primary || {{^multiplePrimary}}''{{/multiplePrimary}}{{#multiplePrimary}}[]{{/multiplePrimary}} === \$primary;
        
        if (false === self::\$allowFullTableUpdates && \$emptyPrimary) { 
            return self::signalError('Restful tables which have a primary key must be updated by its primary key. To bypass this set you may set `self::\$allowFullTableUpdates = true;` during the PREPROCESS events.');
        }
        {{#multiplePrimary}}
        if (false === self::\$allowFullTableUpdates || !\$emptyPrimary) {
            if (count(array_intersect_key(\$primary, self::PRIMARY)) !== count(self::PRIMARY)) {
                return self::signalError('You must provide all primary keys (' . implode(', ', self::PRIMARY) . ').');
            }
            \$where = array_merge(\$argv, \$primary);
        }
        {{/multiplePrimary}}{{^multiplePrimary}}
        if (!\$emptyPrimary) {
            \$where[self::PRIMARY] = \$primary;
        }{{/multiplePrimary}}{{/primaryExists}}{{^primaryExists}}
        
        if (false === self::\$allowFullTableUpdates && empty(\$where)) {
            return self::signalError('Restful tables which have no primary key must be updated using conditions given to \$argv[self::WHERE] and values to be updated given to \$argv[self::UPDATE]. No WHERE attribute given. To bypass this set `self::\$allowFullTableUpdates = true;` during the PREPROCESS events, or just directly before this request.');
        }
        
        if (empty(\$argv)) {
            return self::signalError('Restful tables which have no primary key must be updated using conditions given to \$argv[self::WHERE] and values to be updated given to \$argv[self::UPDATE]. No UPDATE attribute given.');
        }{{/primaryExists}}
        
        foreach (\$argv as \$key => &\$value) {
            if (!array_key_exists(\$key, self::PDO_VALIDATION)){
                return self::signalError('Restful table could not update column \$key, because it does not appear to exist. Please re-run RestBuilder if you beleive this is incorrect.');
            }
            \$op = self::EQUAL;
            if (!self::validateInternalColumn(self::PUT, \$key, \$op, \$value)) {
                return self::signalError('Your custom restful api validations caused the request to fail on column \'{{TableName}}.{{name}}\'.');
            }
        }
        unset(\$value);

        \$sql = /** @lang MySQLFragment */ 'UPDATE {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{TableName}} SET '; // intellij cant handle this otherwise

        \$set = '';

        {{#explode}}
        if (array_key_exists('{{TableName}}.{{name}}', \$argv)) {
            \$set .= '{{name}}={{#binary}}UNHEX(:{{name}}){{/binary}}{{^binary}}:{{name}}{{/binary}},';
        }
        {{/explode}}
        
        \$sql .= substr(\$set, 0, -1);

        \$pdo = self::database();
        
        if (!\$pdo->inTransaction()) {
            \$pdo->beginTransaction();
        }

        if (false === self::\$allowFullTableUpdates || !empty(\$where)) {
            \$sql .= ' WHERE ' . self::buildBooleanJoinConditions(self::PUT, \$where, \$pdo);
        }{{#json}}
        
        self::jsonSQLReporting(func_get_args(), \$sql);{{/json}}

        self::postpreprocessRestRequest(\$sql);

        \$stmt = \$pdo->prepare(\$sql);

        {{#explode}}
        if (array_key_exists('{{TableName}}.{{name}}', \$argv)) { {{^length}}
            \$stmt->bindValue(':{{name}}',{{#json}}json_encode(\$argv['{{TableName}}.{{name}}']){{/json}}{{^json}}\$argv['{{TableName}}.{{name}}']{{/json}}, {{type}});{{/length}}{{#length}}
            \${{name}} = \$argv['{{TableName}}.{{name}}'];
            \$ref = '{{TableName}}.{{name}}';
            \$op = self::EQUAL;
            if (!self::validateInternalColumn(self::PUT, \$ref, \$op, \${{name}})) {
                return self::signalError('Your custom restful api validations caused the request to fail on column \'{{name}}\'.');
            }
            \$stmt->bindParam(':{{name}}',\${{name}}, {{type}}, {{length}});{{/length}}
        }
        {{/explode}}
        
        self::bind(\$stmt);

        if (!\$stmt->execute()) {
            self::completeRest();
            return self::signalError('The REST generated PDOStatement failed to execute with error :: ' . json_encode(\$stmt->errorInfo(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT));
        }
        
        if (!\$stmt->rowCount()) {
            return self::signalError('Failed to find the target row.');
        }
        
        \$argv = array_combine(
            array_map(
                static fn(\$k) => str_replace('{{TableName}}.', '', \$k),
                array_keys(\$argv)
            ),
            array_values(\$argv)
        );

        \$returnUpdated = array_merge(\$returnUpdated, \$argv);
        
        self::prepostprocessRestRequest(\$returnUpdated);
        
        if (self::\$commit && !Database::commit()) {
            return self::signalError('Failed to store commit transaction on table {{TableName}}');
        }
        
        self::postprocessRestRequest(\$returnUpdated);
        
        self::completeRest();
        
        return true;
    }

    /**
    * @param array \$remove{{#primaryExists}}
    * @param {{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}}|null \$primary{{/primaryExists}}
    * @param array \$argv
    * @generated
    * @noinspection DuplicatedCode
    * @throws PublicAlert|PDOException|JsonException
    * @return bool
    */
    public static function Delete(array &\$remove, {{#primaryExists}}{{#multiplePrimary}}array{{/multiplePrimary}}{{^multiplePrimary}}string{{/multiplePrimary}} \$primary = null, {{/primaryExists}}array \$argv = []) : bool
    {
        self::startRest(self::DELETE, \$remove, \$argv{{#primaryExists}}, \$primary{{/primaryExists}});
        
        \$pdo = self::database();{{#primaryExists}}
        
        \$emptyPrimary = null === \$primary || {{^multiplePrimary}}''{{/multiplePrimary}}{{#multiplePrimary}}[]{{/multiplePrimary}} === \$primary;{{/primaryExists}}{{#carbon_table}}
        
        if (!\$emptyPrimary) {
            return Carbons::Delete(\$remove, \$primary, \$argv);
        }

        if (false === self::\$allowFullTableDeletes && empty(\$argv)) {
            return self::signalError('When deleting from restful tables a primary key or where query must be provided.');
        }
        
        \$sql = 'DELETE c FROM {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}carbons c 
                JOIN {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{TableName}} on c.entity_pk = {{#primary}}{{#name}}{{TableName}}.{{name}}{{/name}}{{/primary}}';

        
        if (false === self::\$allowFullTableDeletes || !empty(\$argv)) {
            \$sql .= ' WHERE ' . self::buildBooleanJoinConditions(self::DELETE, \$argv, \$pdo);
        }{{/carbon_table}}{{^carbon_table}}
        
        \$sql =  /** @lang MySQLFragment */ 'DELETE FROM {{^carbon_namespace}}{{#QueryWithDatabaseName}}{{database}}.{{/QueryWithDatabaseName}}{{/carbon_namespace}}{{TableName}} ';{{#primaryExists}}
        
        if (false === self::\$allowFullTableDeletes && \$emptyPrimary && empty(\$argv)) {
            return self::signalError('When deleting from restful tables a primary key or where query must be provided. This can be disabled by setting `self::\$allowFullTableUpdates = true;` during the PREPROCESS events, or just directly before this request.');
        }{{#multiplePrimary}}
        
        \$primaryIntersect = count(array_intersect_key(\$primary, self::PRIMARY));
        
        \$primaryCount = count(\$primary);
        
        if (\$primaryCount !== \$primaryIntersect) {
            return self::signalError('The keys provided to table {{TableName}} was not a subset of (' . implode(', ', self::PRIMARY) . '). Only primary keys associated with the root table requested, thus not joined tables, are allowed.');
        }
        
        if (false === self::\$allowFullTableDeletes && \$primaryIntersect !== count(self::PRIMARY)) {
            return self::signalError('You must provide all primary keys (' . implode(', ', self::PRIMARY) . '). This can be disabled by setting `self::\$allowFullTableUpdates = true;` during the PREPROCESS events, or just directly before this request.');
        }
            
        \$argv = array_merge(\$argv, \$primary);
        {{/multiplePrimary}}{{^multiplePrimary}}
        
        if (!\$emptyPrimary) {
            \$argv[self::PRIMARY] = \$primary;
        }{{/multiplePrimary}}
        
        \$where = self::buildBooleanJoinConditions(self::DELETE, \$argv, \$pdo);
        
        \$emptyWhere = empty(\$where);
        
        if (\$emptyWhere && false === self::\$allowFullTableDeletes) {
            return self::signalError('The where condition provided appears invalid.');
        }

        if (!\$emptyWhere) {
            \$sql .= ' WHERE ' . \$where;
        }{{/primaryExists}}{{^primaryExists}}
        
        if (false === self::\$allowFullTableDeletes && empty(\$argv)) {
            return self::signalError('When deleting from tables with out a primary key additional arguments must be provided.');
        } 
        
        if (!empty(\$argv)) {
            \$sql .= ' WHERE ' . self::buildBooleanJoinConditions(self::DELETE, \$argv, \$pdo);
        }{{/primaryExists}}{{/carbon_table}}
        
        if (!\$pdo->inTransaction()) {
            \$pdo->beginTransaction();
        }{{#json}}
        
        self::jsonSQLReporting(func_get_args(), \$sql);{{/json}}

        self::postpreprocessRestRequest(\$sql);

        \$stmt = \$pdo->prepare(\$sql);

        self::bind(\$stmt);

        if (!\$stmt->execute()) {
            self::completeRest();
            return self::signalError('The REST generated PDOStatement failed to execute with error :: ' . json_encode(\$stmt->errorInfo(), JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT));
        }

        \$remove = [];
        
        self::prepostprocessRestRequest(\$remove);
        
        if (self::\$commit && !Database::commit()) {
           return self::signalError('Failed to store commit transaction on table {{TableName}}');
        }
        
        self::postprocessRestRequest(\$remove);
        
        self::completeRest();
        
        return true;
    }
}

STRING;

    }
}

