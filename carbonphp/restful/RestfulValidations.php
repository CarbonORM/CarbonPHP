<?php


namespace CarbonPHP\Restful;

use CarbonPHP\CarbonPHP;
use CarbonPHP\Error\PublicAlert;
use CarbonPHP\Interfaces\iRest;
use CarbonPHP\Interfaces\iRestMultiplePrimaryKeys;
use CarbonPHP\Interfaces\iRestNoPrimaryKey;
use CarbonPHP\Interfaces\iRestSinglePrimaryKey;
use CarbonPHP\Rest;
use CarbonPHP\Session;

abstract class RestfulValidations
{

    public mixed $validateGeneratedExternalSqlRequestCallback = null;


    /**
     * Simplify a SQL query for better comparisons and security.
     *
     * @param string|null $sql The SQL query to simplify.
     * @return string|null The simplified SQL query or null on failure.
     */
    private static function generalizeSqlForComparison(?string $sql): ?string
    {
        if ($sql === null) {
            return null;
        }

        return preg_replace(
            [
                // :injection0 -> ?
                '/(:injection\d*)/mi',
                // WHERE user_id IN (0,1,2,3) -> WHERE id IN (?)
                '/(?<= ' . iRest::IN . ' \()([^)]*)(?=\))/mi',
                // LIMIT 100,200 -> LIMIT ?
                '/(?<= ' . iRest::LIMIT . ' )(\d*,\d*|\d*)/mi',

            ],
            '?',    // replacing with ? will actually keep it valid sql (generally)
            $sql
        );
    }

    public static function validateGeneratedExternalSqlRequest(string $sql): void
    {
        global $json;

        $fileName = 'validSQL.php';

        if (false === Rest::$externalRestfulRequestsAPI) {

            // we don't need to verify the sql if we are not using the external api
            return;

        }

        $validSqlFile = CarbonPHP::$app_root . $fileName;

        if (false === file_exists($validSqlFile)) {

            $errorMessage = "The file ($validSqlFile) does not exist. Please create a php file that returns an array of values equal to valid sql that can be run from the front end. This is typically autogenerated by the frontend test cases. See the documentation for more information.";

            if (CarbonPHP::$app_local) {

                $json[$fileName] = $errorMessage;

                return;

            }

            throw new PublicAlert($errorMessage);

        }

        $validSql = require $validSqlFile;

        if (false === is_array($validSql)) {

            $errorMessage = "The file ($validSqlFile) does not return an array. Please create a php file that returns an array of values equal to valid sql that can be run from the front end. This is typically autogenerated by the frontend test cases. See the documentation for more information.";

            if (CarbonPHP::$app_local) {

                $json[$fileName] = $errorMessage;

                return;

            }

            throw new PublicAlert($errorMessage);

        }

        $generalizedSql = self::generalizeSqlForComparison($sql);

        foreach ($validSql as $valid) {

            if (self::generalizeSqlForComparison($valid) === $generalizedSql) {

                return;

            }

        }

        if (CarbonPHP::$app_local) {

            $json[$fileName] = "The sql ($sql) is not valid. Please add it to the validSQL.php file.";

            return;

        }

        throw new PublicAlert("The sql ($sql) is not valid. Please add it to the validSQL.php file.");

    }

    /**
     * @param string $columnValue
     * @param string $className
     * @param string $columnName
     * @throws PublicAlert
     */
    public static function validateUnique(string $columnValue, string $className, string $columnName): void
    {

        if (!class_exists($className)) {

            throw new PublicAlert('Rest validation error. Parameters given to validate unique incorrect.');

        }

        $return = [];

        $options = [
            iRestNoPrimaryKey::class,
            iRestSinglePrimaryKey::class,
            iRestMultiplePrimaryKeys::class
        ];

        $imp = array_map('strtolower', array_keys(class_implements($className)));

        $opt = array_map('strtolower', $options);

        // todo - I think this is incorrect
        $intersect = array_intersect($imp, $opt);

        if (empty($intersect)) {
            $imp = implode('|', $options);
            throw new PublicAlert("Rest validation error. The class ($className) passed must extend ($imp).");
        }

        $noPrimary = in_array(strtolower(iRestNoPrimaryKey::class), $intersect, true);

        $query = [
            iRest::WHERE => [
                $columnName => $columnValue
            ],
            iRest::PAGINATION => [
                iRest::LIMIT => 1
            ]
        ];

        if (false === ($noPrimary ?
                $className::Get($return, $query) :
                $className::Get($return, null, $query))) {       // this will work for single or multiple keys
            throw new PublicAlert('Rest validation error. Get request failed in validation.');
        }

        if (!empty($return)) {
            throw new PublicAlert("Oh no! Looks like the value for '$columnName' already exists. Please use a different value and try again.");
        }
    }

    /**
     * @param array $request
     * @param string $column
     * @param string $value
     */
    public static function addToPostRequest(array &$request, string $column, string $value): void
    {
        $request[$column] = $value;
    }

    public static function addIDToPostRequest(array &$request, string $column): void
    {
        $request[$column] = Session::$user_id;
    }

}