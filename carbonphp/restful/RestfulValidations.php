<?php


namespace CarbonPHP\Restful;

use CarbonPHP\CarbonPHP;
use CarbonPHP\Error\PublicAlert;
use CarbonPHP\Interfaces\iRest;
use CarbonPHP\Interfaces\iRestMultiplePrimaryKeys;
use CarbonPHP\Interfaces\iRestNoPrimaryKey;
use CarbonPHP\Interfaces\iRestSinglePrimaryKey;
use CarbonPHP\Rest;
use CarbonPHP\Session;

abstract class RestfulValidations
{

    public static function validateGeneratedExternalSqlRequest(string $sql): void
    {
        global $json;

        $fileName = 'validSQL.php';

        if (false === Rest::$externalRestfulRequestsAPI) {

            // we don't need to verify the sql if we are not using the external api
            return;

        }

        $validSqlFile = CarbonPHP::$app_root . $fileName;

        if (false === file_exists($validSqlFile)) {

            $errorMessage = "The file ($validSqlFile) does not exist. Please create a php file that returns an array of values equal to valid sql that can be run from the front end. This is typically autogenerated by the frontend test cases. See the documentation for more information.";

            if (CarbonPHP::$app_local) {

                $json[$fileName] = $errorMessage;

                return;

            }

            throw new PublicAlert($errorMessage);

        }

        $validSql = require $validSqlFile;

        if (false === is_array($validSql)) {

            $errorMessage = "The file ($validSqlFile) does not return an array. Please create a php file that returns an array of values equal to valid sql that can be run from the front end. This is typically autogenerated by the frontend test cases. See the documentation for more information.";

            if (CarbonPHP::$app_local) {

                $json[$fileName] = $errorMessage;

                return;

            }

            throw new PublicAlert($errorMessage);

        }

        foreach ($validSql as $valid) {

            if ($valid === $sql) {

                return;

            }

        }

        if (CarbonPHP::$app_local) {

            $json[$fileName] = "The sql ($sql) is not valid. Please add it to the validSQL.php file.";

            return;

        }

        throw new PublicAlert("The sql ($sql) is not valid. Please add it to the validSQL.php file.");

    }

    /**
     * @param string $columnValue
     * @param string $className
     * @param string $columnName
     * @throws PublicAlert
     */
    public static function validateUnique(string $columnValue, string $className, string $columnName): void
    {

        if (!class_exists($className)) {

            throw new PublicAlert('Rest validation error. Parameters given to validate unique incorrect.');

        }

        $return = [];

        $options = [
            iRestNoPrimaryKey::class,
            iRestSinglePrimaryKey::class,
            iRestMultiplePrimaryKeys::class
        ];

        $imp = array_map('strtolower', array_keys(class_implements($className)));
        $opt = array_map('strtolower', array_keys(class_implements($options)));
        $intersect = array_intersect($imp, $opt);

        if (empty($intersect)) {
            $imp = implode('|', $options);
            throw new PublicAlert("Rest validation error. The class ($className) passed must extend ($imp).");
        }

        $noPrimary = in_array(strtolower(iRestNoPrimaryKey::class), $intersect, true);

        $query = [
            iRest::WHERE => [
                $columnName => $columnValue
            ],
            iRest::PAGINATION => [
                iRest::LIMIT => 1
            ]
        ];

        if (false === ($noPrimary ?
            $className::Get($return, $query) :
            $className::Get($return, null, $query))) {       // this will work for single or multiple keys
            throw new PublicAlert('Rest validation error. Get request failed in validation.');
        }

        if (!empty($return)) {
            throw new PublicAlert("Oh no! Looks like the value for '$columnName' already exists. Please use a different value and try again.");
        }
    }

    /**
     * @param array $request
     * @param string $column
     * @param string $value
     */
    public static function addToPostRequest(array &$request, string $column, string $value): void
    {
        $request[$column] = $value;
    }

    public static function addIDToPostRequest(array &$request, string $column): void
    {
        $request[$column] = Session::$user_id;
    }

}