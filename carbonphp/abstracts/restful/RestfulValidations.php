<?php


namespace CarbonPHP\Abstracts\Restful;

use CarbonPHP\Abstracts\Rest;
use CarbonPHP\CarbonPHP;
use CarbonPHP\Classes\Exceptions\PrivateAlert;
use CarbonPHP\Classes\Session;
use CarbonPHP\Classes\ThrowableHandler;
use CarbonPHP\Interfaces\iRest;
use CarbonPHP\Interfaces\iRestMultiplePrimaryKeys;
use CarbonPHP\Interfaces\iRestNoPrimaryKey;
use CarbonPHP\Interfaces\iRestSinglePrimaryKey;
use Throwable;

abstract class RestfulValidations
{

    //EXTERNAL_REQUEST_VALID_SQL_CHECK
    public static bool $validateExternalRequestsGeneratedSql = true;


    /**
     * Simplify a SQL query for better comparisons and security.
     *
     * @param string|null $sql The SQL query to simplify.
     * @return string|null The simplified SQL query or null on failure.
     */
    private static function generalizeSqlForComparison(?string $sql): ?string
    {
        if ($sql === null) {
            return null;
        }

        return preg_replace(
            [
                // :injection0 -> ?
                '/(:injection\d*)/mi',
                // WHERE user_id IN (0,1,2,3) -> WHERE id IN (?)
                '/(?<= ' . iRest::IN . ' \()([^)]*)(?=\))/mi',
                // LIMIT 100,200 -> LIMIT ?
                '/(?<= ' . iRest::LIMIT . ' )(\d*,\d*|\d*)/mi',

            ],
            '?',    // replacing with ? will actually keep it valid sql (generally)
            $sql
        );
    }

    public static function validateGeneratedExternalSqlRequest(string $sql): void
    {
        global $json;

        $fileName = 'validSQL.json';

        if (false === Rest::$externalRestfulRequestsAPI) {

            // we don't need to verify the sql if we are not using the external api
            return;

        }

        $shouldExit = self::$validateExternalRequestsGeneratedSql;

        $validSqlFile = CarbonPHP::$app_root . $fileName;

        if (false === file_exists($validSqlFile)) {

            $errorMessage = "The file ($validSqlFile) does not exist. Please create a php file that returns an array of values equal to valid sql that can be run from the front end. This is typically autogenerated by the frontend test cases. See the documentation for more information.";

            if (!$shouldExit) {

                $json[$fileName] = $errorMessage;

                return;

            }

            throw new PrivateAlert($errorMessage);

        }

        try {

            $validSqlArray = json_decode(file_get_contents($validSqlFile), true, 512, JSON_THROW_ON_ERROR);

            $validSqlArray = $validSqlArray['validSQL'];

        } catch (Throwable $e) {

            ThrowableHandler::generateLogAndExit($e);

        }

        if (false === is_array($validSqlArray)) {

            $errorMessage = "The file ($validSqlFile) does not return an array. Please create a php file that returns an array of values equal to valid sql that can be run from the front end. This is typically autogenerated by the frontend test cases. See the documentation for more information.";

            if (!$shouldExit) {

                $json[$fileName] = $errorMessage;

                return;

            }

            throw new PrivateAlert($errorMessage);

        }

        $possibleSql = [];

        $generalizedSql = self::generalizeSqlForComparison($sql);

        foreach ($validSqlArray as $validObject) {

            $validSql = $validObject['stmt']['sql'] ?? '';

            $possibleSql[] = $validSql;

            if ('' === $validSql) {

                continue;

            }

            if (self::generalizeSqlForComparison($validSql) === $generalizedSql) {

                $json['validSQL'] = $validSql;

                return;

            }

        }

        $json['possibleSQL'] = $possibleSql;

        if (!$shouldExit) {

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               $json['invalidSQL'] = [$sql, "The sql is not valid. Please add it to the validSQL.json file."];

            return;

        }

        throw new PrivateAlert("The sql ($sql) is not valid. Please add it to the validSQL.json file. This is typically autogenerated by the frontend test cases. See the documentation for more information.");

    }

    /**
     * @param string $columnValue
     * @param string $className
     * @param string $columnName
     * @throws PrivateAlert
     */
    public static function validateUnique(string $columnValue, string $className, string $columnName): void
    {

        if (!class_exists($className)) {

            throw new PrivateAlert('Rest validation error. Parameters given to validate unique incorrect.');

        }

        $return = [];

        $options = [
            iRestNoPrimaryKey::class,
            iRestSinglePrimaryKey::class,
            iRestMultiplePrimaryKeys::class
        ];

        $imp = array_map('strtolower', array_keys(class_implements($className)));

        $opt = array_map('strtolower', $options);

        // todo - I think this is incorrect
        $intersect = array_intersect($imp, $opt);

        if (empty($intersect)) {
            $imp = implode('|', $options);
            throw new PrivateAlert("Rest validation error. The class ($className) passed must extend ($imp).");
        }

        $noPrimary = in_array(strtolower(iRestNoPrimaryKey::class), $intersect, true);

        $query = [
            iRest::WHERE => [
                $columnName => $columnValue
            ],
            iRest::PAGINATION => [
                iRest::LIMIT => 1
            ]
        ];

        if (false === ($noPrimary ?
                $className::Get($return, $query) :
                $className::Get($return, null, $query))) {       // this will work for single or multiple keys
            throw new PrivateAlert('Rest validation error. Get request failed in validation.');
        }

        if (!empty($return)) {
            throw new PrivateAlert("Oh no! Looks like the value for '$columnName' already exists. Please use a different value and try again.");
        }
    }

    /**
     * @param array $request
     * @param string $column
     * @param string $value
     */
    public static function addToPostRequest(array &$request, string $column, string $value): void
    {
        $request[$column] = $value;
    }

    public static function addIDToPostRequest(array &$request, string $column): void
    {
        $request[$column] = Session::$user_id;
    }

}